[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html",
    "href": "sp/ecocommons-marxan-integration-poc.html",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Author: Zhao Xiang, EcoCommons\nDate: 2024-10-02\n\n\n\n\n\n\n\nUsing the Species distribution modeling techniques provided by the EcoCommons Platform (www.ecocommons.org.au), we produced probability distribution maps for the three Queensland endangered species: koala, brush tailed rock-wallaby, and beach stone curlew.\nThen we adjusted the probability distribution maps of these three species with the planning units shapefile prepared by the Marxan MaPP, and ran four planning scenarios with a target of expanding the coverage of protected areas in QLD to 30%.\n\n\n\n\nSpecies records pulled from GBIF, ALA, EcoPlots, OBIS\nSpecies distribution modelling output: Species distribution Probability maps (This is the input tested in this project).\n\n\n\n\n\nShapefile of planning area and units.\nShapefile of cost.\nShapefile and csv of biodiversity features (Where EcoCommons can help!).\n\n\n\n\nMake sure you are in the directory you want\n\ngetwd()\n\n[1] \"/Users/zhaoxiang/Documents/tmp/notebook-blog/sp\"\n\n# setwd(“/replace_this_with_your_actual_directory/ecocommons-marxan-integration-poc”)\n\nActivate the virtual environment “renv” to install and load all essential packages\n\n# install \"renv\" package if not been installed\nif (!requireNamespace(\"renv\", quietly = TRUE)) {\n  install.packages(\"renv\")\n}\n\nif (!file.exists(\"renv/activate.R\")) {\n   message(\"renv has not been initiated in this project. Initializing now...\")\n   renv::init()  # This initializes renv if it's not set up\n} else {\n   source(\"renv/activate.R\")  # This ensures the renv environment is activated\n   message(\"renv is activated.\")\n}\n\n# Ensure renv is installed and initialized\nif (file.exists(\"renv.lock\")) {\n  renv::restore()\n} else {\n  message(\"No renv.lock file found in the current directory.\")\n}\n\nInstall and load essential packages\n\n# Set CRAN mirror\noptions(repos = c(CRAN = \"https://cran.rstudio.com/\"))\n\n# First specify the packages of interest\npackages = c(\"shiny\", \"sf\", \"terra\", \"ggplot2\", \"ggspatial\", \"raster\", \"dplyr\", \"shiny\", \"httpuv\", \"rmarkdown\", \"knitr\", \"jsonlite\", \"reticulate\", \"htmltools\", \"pryr\")\n\n# Now load or install&load all. This process will take a long time since we are using a virtual environment and install a lot of packages.\npackage.check &lt;- lapply(\n  packages,\n  FUN = function(x) {\n    if (!require(x, character.only = TRUE)) {\n      install.packages(x, dependencies = TRUE)\n      library(x, character.only = TRUE)\n     }\n  }\n )\n\n\nSys.setenv(PROJ_LIB = \"/usr/local/Cellar/proj/9.5.0/share/proj\")\n\nrenv::snapshot()\n\n1. We get the QLD planning units from Marxan MaPP\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Calculate the resolution since Marxan MaPP for visulization purpose\nareas &lt;- st_area(QLD_Unit)\nareas_numeric &lt;- as.numeric(areas)\naverage_area &lt;- mean(areas_numeric)\n\n# Convert to numeric\naverage_area_km2 &lt;- average_area / 1e6\n\n# Get the number of rows\nn_rows &lt;- nrow(QLD_Unit)\n\n# Plot the shapefile with no fill color and number of rows in the title\nggplot(data = QLD_Unit) +\n  geom_sf(fill = NA, color = \"gray\") +\n  theme_minimal() +\n  ggtitle(paste(\"QLD Planning Units:\", n_rows, \"\\n\",\n                \"Resolution of planning in square kilometers:\", round(average_area_km2)))+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n2. I made a cost layer using the reciprocal of the distance to state-owned road as a surrogate of the cost.\nThe assumption is: the closer to the state owned road, the more expensive to purchase the unit.\n\nQLD_cost_road &lt;- st_read(\"qld_3species_Marxan/QLD_Cost/QLD_cost_road.shp\")\n\n# Plot the shapefile with continuous cost_road values\nggplot(QLD_cost_road) +\n  geom_sf(aes(fill = cost_road)) +\n  scale_fill_continuous(name = \"Cost\",\n                        low = \"lightblue\", high = \"red\",\n                        labels = c(\"0 (Low cost)\", \"1 (High cost)\"),\n                        breaks = c(0.01, 1)) +\n  theme_minimal() +\n  labs(title = \"Cost: using the distance to road of each Unit as a proxy\")+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n3. Biodiversity features. I used EcoCommons to produce three species’ SDM to start with.\n\nSpecies 1: koala\nSpecies 2: brush tailed rock-wallaby\nSpecies 3: beach stone curlew\n\n\n# Define the folder path where the rasters are stored\nfolder_path &lt;- \"qld_3species_Marxan/QLD_feature/\"\n\n# Get a list of all .tif files in the folder\nraster_files &lt;- list.files(path = folder_path, pattern = \"\\\\.tif$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Using QLD_Unit as the spatial vector for masking\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Function to convert rasters to data frames and combine them\nprepare_raster_data &lt;- function(raster_list, species_names) {\n\n  # Initialize an empty data frame\n  combined_df &lt;- data.frame()\n  # Loop through each raster and combine them into one data frame\n  for (i in seq_along(raster_list)) {\n    # Convert raster to a data frame\n    raster_df &lt;- as.data.frame(raster_list[[i]], xy = TRUE)\n    # Rename the third column to 'value' or any appropriate name for the raster values\n    names(raster_df)[3] &lt;- \"value\"\n    # Add a column to identify the species name\n    raster_df$species &lt;- species_names[i]\n    # Combine the raster data with the overall data frame\n    combined_df &lt;- bind_rows(combined_df, raster_df)\n}\n  return(combined_df)\n}\n\n# Prepare the combined data frame\ncombined_raster_df &lt;- prepare_raster_data(raster_list, species_names)\n\n# Create the ggplot with facet_wrap to display each raster in a separate facet\nggplot(combined_raster_df, aes(x = x, y = y, fill = value)) +  # Use the correct column name for fill\n  geom_raster()+\n  facet_wrap(~ species, ncol = 3) +  # Adjust ncol to control the number of columns\n  scale_fill_viridis_c() +  # You can adjust the color scale as needed\n  labs(title = \"Species SDM\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n4. We need to turn these SDMs to binary results (shapefies).\n\n# Define the folder paths where the rasters and CSV files are stored\nfolder_path_rasters &lt;- \"qld_3species_Marxan/QLD_feature/\"\nfolder_path_csvs &lt;- \"qld_3species_Marxan/model_evaluation/\"\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Get a list of all .tif files and CSV files in the folder\nraster_files &lt;- list.files(path = folder_path_rasters, pattern = \"\\\\.tif$\", full.names = TRUE)\ncsv_files &lt;- list.files(path = folder_path_csvs, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif/.csv extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Prepare a named list of rasters\nspecies_rasters &lt;- setNames(raster_list, species_names)\nspecies_csvs &lt;- setNames(csv_files, species_names)\n\n# Define UI for the application\nui &lt;- fluidPage(\n  titlePanel(\"Interactive TSS-based threshold for the probability of presence and absence of Species\"),\n  \n  # Use a loop to create a row for each species\n  lapply(species_names, function(species) {\n    fluidRow(\n      column(3, \n             h4(paste(\"Species:\", species)),\n             sliderInput(paste0(\"tss_value_\", species), \n                         \"Select TSS Value:\", \n                         min = 0, max = 1, value = 0.5, step = 0.01),\n             actionButton(paste0(\"run_analysis_\", species), \"Run Species Analysis\"),\n             br(),\n             textOutput(paste0(\"tpr_tnr_\", species))\n      ),\n      \n      column(4, \n             plotOutput(paste0(\"plot_\", species), width = \"400px\")\n      ),\n      \n      column(5, \n             plotOutput(paste0(\"species_plot_\", species))\n      )\n    )\n  })\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  \n  selected_raster &lt;- function(species) {\n    species_rasters[[species]]\n  }\n  \n  species_eval_data &lt;- function(species) {\n    csv_path &lt;- species_csvs[[species]]\n    \n    if (!file.exists(csv_path)) {\n      showNotification(paste(\"CSV file for\", species, \"not found!\"), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data &lt;- read.csv(csv_path)\n    \n    if (!all(c(\"tpr\", \"tnr\", \"tpv\") %in% names(eval_data))) {\n      showNotification(paste(\"Required columns missing in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    if (nrow(eval_data) == 0) {\n      showNotification(paste(\"No data found in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data$tss &lt;- round(eval_data$tpr + eval_data$tnr - 1, 3)\n    return(eval_data)\n  }\n  \n  lapply(species_names, function(species) {\n    eval_data &lt;- species_eval_data(species)\n    \n    if (!is.null(eval_data)) {\n      min_tss &lt;- min(eval_data$tss, na.rm = TRUE)\n      max_tss &lt;- max(eval_data$tss, na.rm = TRUE)\n      \n      updateSliderInput(session, paste0(\"tss_value_\", species), \n                        min = min_tss, \n                        max = max_tss, \n                        value = max_tss,\n                        step = 0.01)\n    }\n    \n    observeEvent(input[[paste0(\"tss_value_\", species)]], {\n      if (!is.null(eval_data)) {\n        row &lt;- which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))\n        \n        tpr &lt;- eval_data$tpr[row]\n        tnr &lt;- eval_data$tnr[row]\n        \n        output[[paste0(\"tpr_tnr_\", species)]] &lt;- renderText({\n          paste0(\"TPR (Sensitivity): \", round(tpr, 3), \n                 \", TNR (Specificity): \", round(tnr, 3))\n        })\n      }\n    })\n    \n    output[[paste0(\"plot_\", species)]] &lt;- renderPlot({\n      if (is.null(eval_data)) return(NULL)\n      \n      ggplot(eval_data, aes(x = tpv)) +\n        geom_line(aes(y = tpr, colour = \"TPR\"), linewidth = 1) +\n        geom_line(aes(y = tnr, colour = \"TNR\"), linewidth = 1) +\n        geom_line(aes(y = tss, colour = \"TSS\"), linewidth = 1) +\n        geom_vline(xintercept = eval_data$tpv[which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))],\n                   linetype = \"dotted\", color = \"red\", linewidth = 1) +\n        labs(title = paste(\"Sensitivity, Specificity, and TSS for\", species),\n             x = \"Threshold Probability Value\",\n             y = \"Value\") +\n        scale_colour_manual(values = c(\"TPR\" = \"blue\", \"TNR\" = \"green\", \"TSS\" = \"red\")) +\n        theme_minimal()\n    })\n    \n    observeEvent(input[[paste0(\"run_analysis_\", species)]], {\n      species_shp &lt;- process_species(selected_raster(species), QLD_Unit, species, output_dir, input[[paste0(\"tss_value_\", species)]])\n      \n      output[[paste0(\"species_plot_\", species)]] &lt;- renderPlot({\n        ggplot() +\n          geom_sf(data = QLD_Unit, fill = NA, color = \"grey\") +\n          geom_sf(data = species_shp, aes(fill = feature), color = NA) +\n          scale_fill_viridis_c(option = \"plasma\") +\n          labs(title = paste(\"Species Distribution for\", species),\n               x = \"Longitude\", y = \"Latitude\") +\n          theme_minimal()\n      })\n    })\n  })\n}\n\nprocess_species &lt;- function(raster_data, planning_unit, species_name, output_dir, tss_threshold) {\n  raster_data_transformed &lt;- project(raster_data, crs(vect(planning_unit)))\n  extracted_values &lt;- extract(raster_data_transformed, vect(planning_unit), fun = mean, na.rm = TRUE)\n  names(planning_unit)[names(planning_unit) == \"cost\"] &lt;- \"feature\"\n  planning_unit$feature &lt;- extracted_values[, 2]\n  \n  QLD_species &lt;- subset(planning_unit, feature &gt;= tss_threshold)\n  shapefile_base &lt;- file.path(output_dir, species_name)\n  st_write(QLD_species, paste0(shapefile_base, \".shp\"), delete_layer = TRUE)\n  \n  return(QLD_species)\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n5. Plot species SDM binary shapefile outputs for double check\n\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\n# List all the shapefiles in the directory (assuming each species has its own shapefile)\nspecies_files &lt;- list.files(output_dir, pattern = \"\\\\.shp$\", full.names = TRUE)\n\nspecies_files\n\n# Extract species names from the filenames (you can adjust this depending on your naming conventions)\nspecies_names &lt;- tools::file_path_sans_ext(basename(species_files))\n\n# Load all species shapefiles and add a species identifier\nspecies_sf_list &lt;- lapply(seq_along(species_files), function(i) {\n  sf &lt;- st_read(species_files[i])\n  sf$species &lt;- species_names[i]  # Add species name column\n  return(sf)\n})\n\n# Combine all species into one dataset\ncombined_species_sf &lt;- do.call(rbind, species_sf_list)\n\n# Plot the unit (base map) first and overlay the species habitats without borders\ncombined_plot_with_unit &lt;- ggplot() +\n  geom_sf(data = QLD_Unit, fill = NA, color = \"grey\", linewidth = 0.01) +  # Base map (QLD Unit)\n  geom_sf(data = combined_species_sf, aes(fill = species), color = NA) +  # No borders for species\n  scale_fill_manual(values = RColorBrewer::brewer.pal(n = length(species_names), name = \"Set1\")) +  # Automatically assign colors\n  theme_minimal() +\n  labs(title = \"Species Habitats within QLD Unit\",\n       subtitle = paste(species_names, collapse = \", \")) +  # List all species in subtitle\n  theme(legend.title = element_blank())\n\n# Display the plot\nprint(combined_plot_with_unit)\n\n\n\n\n\n\n\n\n6. We can also make a species presence and absence csv table.\n\n# Function to extract presence (1) and absence (0) from raster based on a threshold (e.g., 0.5)\n\nextract_presence_absence &lt;- function(raster_data, unit) {\n  extracted_values &lt;- extract(raster_data, vect(unit), fun = mean, na.rm = TRUE)\n  presence_absence &lt;- ifelse(extracted_values[, 2] &gt;= 0.5, 1, 0)\n  return(presence_absence)\n}\n\n# Create an empty presence-absence data frame\npresence_absence_df &lt;- data.frame(puid = QLD_Unit$puid)  # Assuming 'puid' is the unique identifier\n\n# Loop through each species raster in the raster list and extract presence-absence data\nfor (i in seq_along(raster_list)) {\n  # Generate a dynamic presence column name for the current species\n  presence_col_name &lt;- paste0(species_names[i], \"_presence\")\n  \n  # Extract presence/absence data and add it to the presence-absence dataframe\n  presence_absence_df[[species_names[i]]] &lt;- extract_presence_absence(raster_list[[i]], QLD_Unit)\n}\n\n# Write the final presence-absence data frame to a CSV file\noutput_csv &lt;- file.path(output_dir, \"presence_absence_species.csv\")\nwrite.csv(presence_absence_df, output_csv, row.names = FALSE)\n\n# Check the CSV output\nprint(head(presence_absence_df))\n\n  puid beach_stone_curlew_GLM brushtailed_rockwallaby_GLM Koala_GLM\n1    1                      0                           0         0\n2    2                      0                           0         0\n3    3                      0                           0         0\n4    4                      0                           0         0\n5    5                      0                           0         0\n6    6                      0                           0         0\n\n\n\n\n\n\n\n\n\n\nEcoCommons SDMs output of three species on Marxan MaPP\n\n\n\n\n\n\n\n\nNo Costs, neither SDMs\n\n\n\n\n\n\n\n\nSDMs only\n\n\n\n\n\n\n\n\nCosts only\n\n\n\n\n\n\n\n\nCosts and SDMs"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#introduction",
    "href": "sp/ecocommons-marxan-integration-poc.html#introduction",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Using the Species distribution modeling techniques provided by the EcoCommons Platform (www.ecocommons.org.au), we produced probability distribution maps for the three Queensland endangered species: koala, brush tailed rock-wallaby, and beach stone curlew.\nThen we adjusted the probability distribution maps of these three species with the planning units shapefile prepared by the Marxan MaPP, and ran four planning scenarios with a target of expanding the coverage of protected areas in QLD to 30%."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#ecocommons-outputs",
    "href": "sp/ecocommons-marxan-integration-poc.html#ecocommons-outputs",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Species records pulled from GBIF, ALA, EcoPlots, OBIS\nSpecies distribution modelling output: Species distribution Probability maps (This is the input tested in this project)."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#marxan-mapp-inputs",
    "href": "sp/ecocommons-marxan-integration-poc.html#marxan-mapp-inputs",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Shapefile of planning area and units.\nShapefile of cost.\nShapefile and csv of biodiversity features (Where EcoCommons can help!)."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#ecocommons-connects-with-marxan-showcase",
    "href": "sp/ecocommons-marxan-integration-poc.html#ecocommons-connects-with-marxan-showcase",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Make sure you are in the directory you want\n\ngetwd()\n\n[1] \"/Users/zhaoxiang/Documents/tmp/notebook-blog/sp\"\n\n# setwd(“/replace_this_with_your_actual_directory/ecocommons-marxan-integration-poc”)\n\nActivate the virtual environment “renv” to install and load all essential packages\n\n# install \"renv\" package if not been installed\nif (!requireNamespace(\"renv\", quietly = TRUE)) {\n  install.packages(\"renv\")\n}\n\nif (!file.exists(\"renv/activate.R\")) {\n   message(\"renv has not been initiated in this project. Initializing now...\")\n   renv::init()  # This initializes renv if it's not set up\n} else {\n   source(\"renv/activate.R\")  # This ensures the renv environment is activated\n   message(\"renv is activated.\")\n}\n\n# Ensure renv is installed and initialized\nif (file.exists(\"renv.lock\")) {\n  renv::restore()\n} else {\n  message(\"No renv.lock file found in the current directory.\")\n}\n\nInstall and load essential packages\n\n# Set CRAN mirror\noptions(repos = c(CRAN = \"https://cran.rstudio.com/\"))\n\n# First specify the packages of interest\npackages = c(\"shiny\", \"sf\", \"terra\", \"ggplot2\", \"ggspatial\", \"raster\", \"dplyr\", \"shiny\", \"httpuv\", \"rmarkdown\", \"knitr\", \"jsonlite\", \"reticulate\", \"htmltools\", \"pryr\")\n\n# Now load or install&load all. This process will take a long time since we are using a virtual environment and install a lot of packages.\npackage.check &lt;- lapply(\n  packages,\n  FUN = function(x) {\n    if (!require(x, character.only = TRUE)) {\n      install.packages(x, dependencies = TRUE)\n      library(x, character.only = TRUE)\n     }\n  }\n )\n\n\nSys.setenv(PROJ_LIB = \"/usr/local/Cellar/proj/9.5.0/share/proj\")\n\nrenv::snapshot()\n\n1. We get the QLD planning units from Marxan MaPP\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Calculate the resolution since Marxan MaPP for visulization purpose\nareas &lt;- st_area(QLD_Unit)\nareas_numeric &lt;- as.numeric(areas)\naverage_area &lt;- mean(areas_numeric)\n\n# Convert to numeric\naverage_area_km2 &lt;- average_area / 1e6\n\n# Get the number of rows\nn_rows &lt;- nrow(QLD_Unit)\n\n# Plot the shapefile with no fill color and number of rows in the title\nggplot(data = QLD_Unit) +\n  geom_sf(fill = NA, color = \"gray\") +\n  theme_minimal() +\n  ggtitle(paste(\"QLD Planning Units:\", n_rows, \"\\n\",\n                \"Resolution of planning in square kilometers:\", round(average_area_km2)))+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n2. I made a cost layer using the reciprocal of the distance to state-owned road as a surrogate of the cost.\nThe assumption is: the closer to the state owned road, the more expensive to purchase the unit.\n\nQLD_cost_road &lt;- st_read(\"qld_3species_Marxan/QLD_Cost/QLD_cost_road.shp\")\n\n# Plot the shapefile with continuous cost_road values\nggplot(QLD_cost_road) +\n  geom_sf(aes(fill = cost_road)) +\n  scale_fill_continuous(name = \"Cost\",\n                        low = \"lightblue\", high = \"red\",\n                        labels = c(\"0 (Low cost)\", \"1 (High cost)\"),\n                        breaks = c(0.01, 1)) +\n  theme_minimal() +\n  labs(title = \"Cost: using the distance to road of each Unit as a proxy\")+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n3. Biodiversity features. I used EcoCommons to produce three species’ SDM to start with.\n\nSpecies 1: koala\nSpecies 2: brush tailed rock-wallaby\nSpecies 3: beach stone curlew\n\n\n# Define the folder path where the rasters are stored\nfolder_path &lt;- \"qld_3species_Marxan/QLD_feature/\"\n\n# Get a list of all .tif files in the folder\nraster_files &lt;- list.files(path = folder_path, pattern = \"\\\\.tif$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Using QLD_Unit as the spatial vector for masking\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Function to convert rasters to data frames and combine them\nprepare_raster_data &lt;- function(raster_list, species_names) {\n\n  # Initialize an empty data frame\n  combined_df &lt;- data.frame()\n  # Loop through each raster and combine them into one data frame\n  for (i in seq_along(raster_list)) {\n    # Convert raster to a data frame\n    raster_df &lt;- as.data.frame(raster_list[[i]], xy = TRUE)\n    # Rename the third column to 'value' or any appropriate name for the raster values\n    names(raster_df)[3] &lt;- \"value\"\n    # Add a column to identify the species name\n    raster_df$species &lt;- species_names[i]\n    # Combine the raster data with the overall data frame\n    combined_df &lt;- bind_rows(combined_df, raster_df)\n}\n  return(combined_df)\n}\n\n# Prepare the combined data frame\ncombined_raster_df &lt;- prepare_raster_data(raster_list, species_names)\n\n# Create the ggplot with facet_wrap to display each raster in a separate facet\nggplot(combined_raster_df, aes(x = x, y = y, fill = value)) +  # Use the correct column name for fill\n  geom_raster()+\n  facet_wrap(~ species, ncol = 3) +  # Adjust ncol to control the number of columns\n  scale_fill_viridis_c() +  # You can adjust the color scale as needed\n  labs(title = \"Species SDM\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n4. We need to turn these SDMs to binary results (shapefies).\n\n# Define the folder paths where the rasters and CSV files are stored\nfolder_path_rasters &lt;- \"qld_3species_Marxan/QLD_feature/\"\nfolder_path_csvs &lt;- \"qld_3species_Marxan/model_evaluation/\"\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Get a list of all .tif files and CSV files in the folder\nraster_files &lt;- list.files(path = folder_path_rasters, pattern = \"\\\\.tif$\", full.names = TRUE)\ncsv_files &lt;- list.files(path = folder_path_csvs, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif/.csv extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Prepare a named list of rasters\nspecies_rasters &lt;- setNames(raster_list, species_names)\nspecies_csvs &lt;- setNames(csv_files, species_names)\n\n# Define UI for the application\nui &lt;- fluidPage(\n  titlePanel(\"Interactive TSS-based threshold for the probability of presence and absence of Species\"),\n  \n  # Use a loop to create a row for each species\n  lapply(species_names, function(species) {\n    fluidRow(\n      column(3, \n             h4(paste(\"Species:\", species)),\n             sliderInput(paste0(\"tss_value_\", species), \n                         \"Select TSS Value:\", \n                         min = 0, max = 1, value = 0.5, step = 0.01),\n             actionButton(paste0(\"run_analysis_\", species), \"Run Species Analysis\"),\n             br(),\n             textOutput(paste0(\"tpr_tnr_\", species))\n      ),\n      \n      column(4, \n             plotOutput(paste0(\"plot_\", species), width = \"400px\")\n      ),\n      \n      column(5, \n             plotOutput(paste0(\"species_plot_\", species))\n      )\n    )\n  })\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  \n  selected_raster &lt;- function(species) {\n    species_rasters[[species]]\n  }\n  \n  species_eval_data &lt;- function(species) {\n    csv_path &lt;- species_csvs[[species]]\n    \n    if (!file.exists(csv_path)) {\n      showNotification(paste(\"CSV file for\", species, \"not found!\"), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data &lt;- read.csv(csv_path)\n    \n    if (!all(c(\"tpr\", \"tnr\", \"tpv\") %in% names(eval_data))) {\n      showNotification(paste(\"Required columns missing in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    if (nrow(eval_data) == 0) {\n      showNotification(paste(\"No data found in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data$tss &lt;- round(eval_data$tpr + eval_data$tnr - 1, 3)\n    return(eval_data)\n  }\n  \n  lapply(species_names, function(species) {\n    eval_data &lt;- species_eval_data(species)\n    \n    if (!is.null(eval_data)) {\n      min_tss &lt;- min(eval_data$tss, na.rm = TRUE)\n      max_tss &lt;- max(eval_data$tss, na.rm = TRUE)\n      \n      updateSliderInput(session, paste0(\"tss_value_\", species), \n                        min = min_tss, \n                        max = max_tss, \n                        value = max_tss,\n                        step = 0.01)\n    }\n    \n    observeEvent(input[[paste0(\"tss_value_\", species)]], {\n      if (!is.null(eval_data)) {\n        row &lt;- which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))\n        \n        tpr &lt;- eval_data$tpr[row]\n        tnr &lt;- eval_data$tnr[row]\n        \n        output[[paste0(\"tpr_tnr_\", species)]] &lt;- renderText({\n          paste0(\"TPR (Sensitivity): \", round(tpr, 3), \n                 \", TNR (Specificity): \", round(tnr, 3))\n        })\n      }\n    })\n    \n    output[[paste0(\"plot_\", species)]] &lt;- renderPlot({\n      if (is.null(eval_data)) return(NULL)\n      \n      ggplot(eval_data, aes(x = tpv)) +\n        geom_line(aes(y = tpr, colour = \"TPR\"), linewidth = 1) +\n        geom_line(aes(y = tnr, colour = \"TNR\"), linewidth = 1) +\n        geom_line(aes(y = tss, colour = \"TSS\"), linewidth = 1) +\n        geom_vline(xintercept = eval_data$tpv[which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))],\n                   linetype = \"dotted\", color = \"red\", linewidth = 1) +\n        labs(title = paste(\"Sensitivity, Specificity, and TSS for\", species),\n             x = \"Threshold Probability Value\",\n             y = \"Value\") +\n        scale_colour_manual(values = c(\"TPR\" = \"blue\", \"TNR\" = \"green\", \"TSS\" = \"red\")) +\n        theme_minimal()\n    })\n    \n    observeEvent(input[[paste0(\"run_analysis_\", species)]], {\n      species_shp &lt;- process_species(selected_raster(species), QLD_Unit, species, output_dir, input[[paste0(\"tss_value_\", species)]])\n      \n      output[[paste0(\"species_plot_\", species)]] &lt;- renderPlot({\n        ggplot() +\n          geom_sf(data = QLD_Unit, fill = NA, color = \"grey\") +\n          geom_sf(data = species_shp, aes(fill = feature), color = NA) +\n          scale_fill_viridis_c(option = \"plasma\") +\n          labs(title = paste(\"Species Distribution for\", species),\n               x = \"Longitude\", y = \"Latitude\") +\n          theme_minimal()\n      })\n    })\n  })\n}\n\nprocess_species &lt;- function(raster_data, planning_unit, species_name, output_dir, tss_threshold) {\n  raster_data_transformed &lt;- project(raster_data, crs(vect(planning_unit)))\n  extracted_values &lt;- extract(raster_data_transformed, vect(planning_unit), fun = mean, na.rm = TRUE)\n  names(planning_unit)[names(planning_unit) == \"cost\"] &lt;- \"feature\"\n  planning_unit$feature &lt;- extracted_values[, 2]\n  \n  QLD_species &lt;- subset(planning_unit, feature &gt;= tss_threshold)\n  shapefile_base &lt;- file.path(output_dir, species_name)\n  st_write(QLD_species, paste0(shapefile_base, \".shp\"), delete_layer = TRUE)\n  \n  return(QLD_species)\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n5. Plot species SDM binary shapefile outputs for double check\n\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\n# List all the shapefiles in the directory (assuming each species has its own shapefile)\nspecies_files &lt;- list.files(output_dir, pattern = \"\\\\.shp$\", full.names = TRUE)\n\nspecies_files\n\n# Extract species names from the filenames (you can adjust this depending on your naming conventions)\nspecies_names &lt;- tools::file_path_sans_ext(basename(species_files))\n\n# Load all species shapefiles and add a species identifier\nspecies_sf_list &lt;- lapply(seq_along(species_files), function(i) {\n  sf &lt;- st_read(species_files[i])\n  sf$species &lt;- species_names[i]  # Add species name column\n  return(sf)\n})\n\n# Combine all species into one dataset\ncombined_species_sf &lt;- do.call(rbind, species_sf_list)\n\n# Plot the unit (base map) first and overlay the species habitats without borders\ncombined_plot_with_unit &lt;- ggplot() +\n  geom_sf(data = QLD_Unit, fill = NA, color = \"grey\", linewidth = 0.01) +  # Base map (QLD Unit)\n  geom_sf(data = combined_species_sf, aes(fill = species), color = NA) +  # No borders for species\n  scale_fill_manual(values = RColorBrewer::brewer.pal(n = length(species_names), name = \"Set1\")) +  # Automatically assign colors\n  theme_minimal() +\n  labs(title = \"Species Habitats within QLD Unit\",\n       subtitle = paste(species_names, collapse = \", \")) +  # List all species in subtitle\n  theme(legend.title = element_blank())\n\n# Display the plot\nprint(combined_plot_with_unit)\n\n\n\n\n\n\n\n\n6. We can also make a species presence and absence csv table.\n\n# Function to extract presence (1) and absence (0) from raster based on a threshold (e.g., 0.5)\n\nextract_presence_absence &lt;- function(raster_data, unit) {\n  extracted_values &lt;- extract(raster_data, vect(unit), fun = mean, na.rm = TRUE)\n  presence_absence &lt;- ifelse(extracted_values[, 2] &gt;= 0.5, 1, 0)\n  return(presence_absence)\n}\n\n# Create an empty presence-absence data frame\npresence_absence_df &lt;- data.frame(puid = QLD_Unit$puid)  # Assuming 'puid' is the unique identifier\n\n# Loop through each species raster in the raster list and extract presence-absence data\nfor (i in seq_along(raster_list)) {\n  # Generate a dynamic presence column name for the current species\n  presence_col_name &lt;- paste0(species_names[i], \"_presence\")\n  \n  # Extract presence/absence data and add it to the presence-absence dataframe\n  presence_absence_df[[species_names[i]]] &lt;- extract_presence_absence(raster_list[[i]], QLD_Unit)\n}\n\n# Write the final presence-absence data frame to a CSV file\noutput_csv &lt;- file.path(output_dir, \"presence_absence_species.csv\")\nwrite.csv(presence_absence_df, output_csv, row.names = FALSE)\n\n# Check the CSV output\nprint(head(presence_absence_df))\n\n  puid beach_stone_curlew_GLM brushtailed_rockwallaby_GLM Koala_GLM\n1    1                      0                           0         0\n2    2                      0                           0         0\n3    3                      0                           0         0\n4    4                      0                           0         0\n5    5                      0                           0         0\n6    6                      0                           0         0"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#marxan-four-scenarios-solutions",
    "href": "sp/ecocommons-marxan-integration-poc.html#marxan-four-scenarios-solutions",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "EcoCommons SDMs output of three species on Marxan MaPP\n\n\n\n\n\n\n\n\nNo Costs, neither SDMs\n\n\n\n\n\n\n\n\nSDMs only\n\n\n\n\n\n\n\n\nCosts only\n\n\n\n\n\n\n\n\nCosts and SDMs"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ecr-notebooks",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  }
]