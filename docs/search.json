[
  {
    "objectID": "sdms/raster_preparation.html#environmental-variables",
    "href": "sdms/raster_preparation.html#environmental-variables",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "1. Environmental variables",
    "text": "1. Environmental variables\nIn Species Distribution Modeling (SDM), environmental variables are factors that influence where a species can live. These include:\n\nClimatic Variables: Temperature, precipitation.\nTopographic Variables: Elevation, slope.\nSoil Variables: Soil pH, texture.\nVegetation Variables: Land cover type, canopy cover.\nHydrological Variables: Distance to water bodies, soil moisture.\nBiotic Variables: Presence of prey, competitors.\nAnthropogenic Variables: Land use, human impact.\n\nThese variables help explain and predict a species’ habitat suitability based on environmental conditions."
  },
  {
    "objectID": "sdms/raster_preparation.html#raster",
    "href": "sdms/raster_preparation.html#raster",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "2. Raster",
    "text": "2. Raster\nRaster data is a type of spatial data used to represent continuous surfaces, like environmental layers (e.g., elevation, temperature) in grids or cells. Each cell (pixel) has a value that represents information about that area.\nImportant Characteristics:\n\nResolution: Size of each cell, determining data detail (e.g., 10m x 10m cells).\nExtent: Geographic area covered by the raster.\nCoordinate Reference System (CRS): Defines the spatial reference of the raster for location accuracy.\nData Type: Can be continuous (e.g., temperature) or categorical (e.g., land cover type).\n\nThese characteristics impact how raster data is interpreted and used in analyses like SDM.\nTo make extract the value of raster data, we always want our raster data has the same resolution, extend, and CRS."
  },
  {
    "objectID": "sdms/raster_preparation.html#categorical-and-continuous-data",
    "href": "sdms/raster_preparation.html#categorical-and-continuous-data",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "3. Categorical and Continuous data",
    "text": "3. Categorical and Continuous data\nIn environmental modeling, environmental variables can be classified as categorical or continuous:\nCategorical Data\n\nRepresents discrete classes or categories.\nExamples:\n\nLand Cover Type: Forest, grassland, urban.\nSoil Type: Sandy, clay, loam.\nVegetation Type: Different plant communities.\n\n\nContinuous Data\n\nRepresents data with a smooth gradient, measurable values.\nExamples:\n\nTemperature: Annual mean temperature.\nPrecipitation: Monthly or annual rainfall.\nElevation: Height above sea level in meters.\n\n\nCategorical data is useful for distinct classifications, while continuous data is used for variables that change gradually across the landscape. Both types are important for predicting species distributions."
  },
  {
    "objectID": "sdms/raster_preparation.html#set-working-directory-and-make-a-folder-to-store-data.",
    "href": "sdms/raster_preparation.html#set-working-directory-and-make-a-folder-to-store-data.",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "1. Set working directory and make a folder to store data.",
    "text": "1. Set working directory and make a folder to store data.\n\n# Set Workspace as the current working directory\nworkspace &lt;- getwd()\n\n# Define directory for storing environmental data\nenv_data_dir &lt;- file.path(workspace, \"env_data\")\n\n# Create 'env_data' directory if it doesn't exist\nif (!dir.exists(env_data_dir)) {\n  dir.create(env_data_dir, recursive = TRUE)\n  cat(\"Directory 'env_data' created successfully.\\n\")\n} else {\n  cat(\"Directory 'env_data' already exists.\\n\")\n}\n\nDirectory 'env_data' already exists."
  },
  {
    "objectID": "sdms/raster_preparation.html#install-and-load-essential-libraries.",
    "href": "sdms/raster_preparation.html#install-and-load-essential-libraries.",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "2. Install and load essential libraries.",
    "text": "2. Install and load essential libraries.\n\n# List of packages to check, install if needed, and load\npackages &lt;- c(\"dplyr\", \"terra\", \"sf\", \"googledrive\", \"ggplot2\")\n\n# Install missing packages and load them\nfor (pkg in packages) {\n  if (!pkg %in% installed.packages()[, \"Package\"]) {\n    install.packages(pkg)\n  }\n  library(pkg, character.only = TRUE)\n}\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nterra 1.7.78\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n# De-authenticate Google Drive to access public files\ndrive_deauth()"
  },
  {
    "objectID": "sdms/raster_preparation.html#download-environmental-data",
    "href": "sdms/raster_preparation.html#download-environmental-data",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "3. Download Environmental Data",
    "text": "3. Download Environmental Data\nEnvironmental variables are downloaded from both WorldClim and Google Drive, and stored in GeoTIFF format.\n\nlibrary(googledrive)\ndrive_deauth()  # Access public files without authentication\n\n\n# Define Google Drive file IDs and corresponding local file paths for environmental variables\nfile_ids &lt;- list(\n  env_var_1 = \"1EA_lberXjNI3_RRM0mbAdDvVDTFL2tW3\", # Continuous Environmental Variable 1, Bioclim 01\n  env_var_2 = \"1PO1TAQp-ND4olSgIQ29wjexMOQnhXkku\", # Continuous Environmental Variable 2, Bioclim 02\n  env_var_3 = \"1BSEuphUV-qqR-gnA9HPZ1qKGLyJfLagC\", # Continuous Environmental Variable 3, Bioclim 03\n  env_var_4 = \"1fCI5D_AGg2nhU75A-9WX7MspcrQYMp7f\", # Continuous Environmental Variable 4, Bioclim 04\n  env_var_5 = \"1yWmJ9fKFPZQoV_XTRIWABV_gaF-wexzZ\", # Continuous Environmental Variable 5, Bioclim 05\n  env_var_cat_1 = \"1WzBKghFdG67C_LMeOmi9a1A12wjrd9wo\" # Categorical Environmental Variable 1, Land use of Australia\n)\n\n\n# Define local file paths for each environmental variable\nfile_paths &lt;- list(\n  env_var_1 = file.path(workspace, \"env_data\", \"env_var_1.tif\"),\n  env_var_2 = file.path(workspace, \"env_data\", \"env_var_2.tif\"),\n  env_var_3 = file.path(workspace, \"env_data\", \"env_var_3.tif\"),\n  env_var_4 = file.path(workspace, \"env_data\", \"env_var_4.tif\"),\n  env_var_5 = file.path(workspace, \"env_data\", \"env_var_5.tif\"),\n  env_var_cat_1 = file.path(workspace, \"env_data\", \"env_var_cat_1.tif\")\n)\n\n# Function to download individual files with progress messages\ndownload_file &lt;- function(file_id, file_path) {\n  cat(\"Downloading:\", basename(file_path), \"...\\n\")\n  drive_download(as_id(file_id), path = file_path, overwrite = TRUE)\n  cat(\"Downloaded:\", basename(file_path), \"\\n\")\n}\n\n# Download each environmental variable file\ncat(\"Downloading environmental variable files...\\n\")\n\nDownloading environmental variable files...\n\ninvisible(mapply(download_file, file_ids, file_paths))\n\nDownloading: env_var_1.tif ...\n\n\nFile downloaded:\n\n\n• 'wc2.1_2.5m_bioclim_01.tif' &lt;id: 1EA_lberXjNI3_RRM0mbAdDvVDTFL2tW3&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_1.tif'\n\n\nDownloaded: env_var_1.tif \nDownloading: env_var_2.tif ...\n\n\nFile downloaded:\n\n\n• 'wc2.1_2.5m_bioclim_02.tif' &lt;id: 1PO1TAQp-ND4olSgIQ29wjexMOQnhXkku&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_2.tif'\n\n\nDownloaded: env_var_2.tif \nDownloading: env_var_3.tif ...\n\n\nFile downloaded:\n\n\n• 'wc2.1_2.5m_bioclim_03.tif' &lt;id: 1BSEuphUV-qqR-gnA9HPZ1qKGLyJfLagC&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_3.tif'\n\n\nDownloaded: env_var_3.tif \nDownloading: env_var_4.tif ...\n\n\nFile downloaded:\n\n\n• 'wc2.1_2.5m_bioclim_04.tif' &lt;id: 1fCI5D_AGg2nhU75A-9WX7MspcrQYMp7f&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_4.tif'\n\n\nDownloaded: env_var_4.tif \nDownloading: env_var_5.tif ...\n\n\nFile downloaded:\n\n\n• 'wc2.1_2.5m_bioclim_05.tif' &lt;id: 1yWmJ9fKFPZQoV_XTRIWABV_gaF-wexzZ&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_5.tif'\n\n\nDownloaded: env_var_5.tif \nDownloading: env_var_cat_1.tif ...\n\n\nFile downloaded:\n\n\n• 'land_use_Australia_6class_cat.tif' &lt;id: 1WzBKghFdG67C_LMeOmi9a1A12wjrd9wo&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/env_var_cat_1.tif'\n\n\nDownloaded: env_var_cat_1.tif \n\n# Confirm the files have been downloaded\ndownloaded_files &lt;- list.files(file.path(workspace, \"env_data\"), recursive = TRUE)\ncat(\"Downloaded files:\\n\", downloaded_files, \"\\n\")\n\nDownloaded files:\n aus_shapefile/AUS_2021_AUST_GDA2020.dbf aus_shapefile/AUS_2021_AUST_GDA2020.prj aus_shapefile/AUS_2021_AUST_GDA2020.shp aus_shapefile/AUS_2021_AUST_GDA2020.shx aus_shapefile/AUS_2021_AUST_GDA2020.xml env_var_1.tif env_var_2.tif env_var_3.tif env_var_4.tif env_var_5.tif env_var_cat_1.tif"
  },
  {
    "objectID": "sdms/raster_preparation.html#load-and-process-environmental-data",
    "href": "sdms/raster_preparation.html#load-and-process-environmental-data",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "4. Load and Process Environmental Data",
    "text": "4. Load and Process Environmental Data\nAll raster files are loaded and reprojected if necessary to ensure consistency.\n\n# Load all rasters and store in a list\nrasters &lt;- lapply(file_paths, rast)\n\n\n# Sometimes, when you upload a raster file (such as a GeoTIFF) to Google Drive and then open it in Google Colab, it may lose its categorical (factor) properties due to how terra or other spatial libraries interpret the file upon reloading. Rasters saved as categorical may be stored with integer values rather than explicit factor levels in the file, meaning they need to be redefined as factors when reloaded.\n\nrasters[[6]] &lt;- as.factor(rasters[[6]])\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# Check if each raster is categorical or continuous\nfor (i in seq_along(rasters)) {\n  if (is.factor(rasters[[i]])) {\n    cat(\"Raster\", i, \"is categorical.\\n\")\n  } else {\n    cat(\"Raster\", i, \"is continuous.\\n\")\n  }\n}\n\nRaster 1 is continuous.\nRaster 2 is continuous.\nRaster 3 is continuous.\nRaster 4 is continuous.\nRaster 5 is continuous.\nRaster 6 is categorical."
  },
  {
    "objectID": "sdms/raster_preparation.html#download-and-load-australian-boundary-shapefile",
    "href": "sdms/raster_preparation.html#download-and-load-australian-boundary-shapefile",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "5. Download and Load Australian Boundary Shapefile",
    "text": "5. Download and Load Australian Boundary Shapefile\n\nlibrary(googledrive)\n\n# De-authenticate Google Drive to access public files\ndrive_deauth()\n\n# Folder ID for the Australian polygon shapefile\naus_folder_id &lt;- \"1rzNHthnQQXVulocKkB5i7v2dObqKMP11\"\n\n# Define the local directory to save the shapefile components\nshapefile_dir &lt;- file.path(workspace, \"env_data\", \"aus_shapefile\")\ndir.create(shapefile_dir, showWarnings = FALSE, recursive = TRUE)\n\n# List all files in the shapefile folder on Google Drive\nfiles_in_folder &lt;- drive_ls(as_id(aus_folder_id))\n\n# Download each file in the folder\ncat(\"Downloading shapefile components...\\n\")\n\nDownloading shapefile components...\n\nfor (i in 1:nrow(files_in_folder)) {\n  file_name &lt;- files_in_folder$name[i]\n  cat(\"Downloading:\", file_name, \"...\\n\")\n  drive_download(files_in_folder$id[i], path = file.path(shapefile_dir, file_name), overwrite = TRUE)\n}\n\nDownloading: AUS_2021_AUST_GDA2020.xml ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.xml' &lt;id: 1BxMyIxENdWJ2RiZxK_8Ay_0r2Uvad5Wd&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.xml'\n\n\nDownloading: AUS_2021_AUST_GDA2020.shx ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.shx' &lt;id: 1wfSxFsmgK4V44f4ZJhYy3V6wL16YpVWe&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.shx'\n\n\nDownloading: AUS_2021_AUST_GDA2020.dbf ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.dbf' &lt;id: 1gdWxQ5aOB_KuejlHn254K7RwdtDR2N8f&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.dbf'\n\n\nDownloading: AUS_2021_AUST_GDA2020.prj ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.prj' &lt;id: 1Fi9K9mWOpvksSkH0CGJN9XlKf8-1LjSj&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.prj'\n\n\nDownloading: AUS_2021_AUST_GDA2020.shp ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.shp' &lt;id: 1ZWGQYHbygM-MCFyON76FXwj7uHwJnpxH&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.shp'\n\ncat(\"Shapefile components downloaded to:\", shapefile_dir, \"\\n\")\n\nShapefile components downloaded to: /Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile \n\n# Load necessary library for handling shapefiles\nlibrary(terra)\n\n# Load the shapefile using the components in the downloaded directory\nshapefile_path &lt;- list.files(shapefile_dir, pattern = \"\\\\.shp$\", full.names = TRUE)\n\n# Load the Australian boundary as an sf object and convert to EPSG 4326\naustralia_boundary &lt;- st_read(shapefile_path)\n\nReading layer `AUS_2021_AUST_GDA2020' from data source \n  `/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sdms/env_data/aus_shapefile/AUS_2021_AUST_GDA2020.shp' \n  using driver `ESRI Shapefile'\nreplacing null geometries with empty geometries\nSimple feature collection with 2 features and 6 fields (with 1 geometry empty)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.81695 ymin: -43.7405 xmax: 167.998 ymax: -9.142163\nGeodetic CRS:  GDA2020\n\naustralia_boundary &lt;- st_transform(australia_boundary, crs = 4326)\n\nclass(australia_boundary)\n\n[1] \"sf\"         \"data.frame\""
  },
  {
    "objectID": "sdms/raster_preparation.html#plot-australian-boundary",
    "href": "sdms/raster_preparation.html#plot-australian-boundary",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "6. Plot Australian Boundary",
    "text": "6. Plot Australian Boundary\n\nlibrary(ggplot2)\n\nggplot(data = australia_boundary) +\n  geom_sf(fill = \"#61c6fa\", color = \"black\") +  # Fill with light blue and outline in black\n  labs(title = \"Map of Australia\") +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 18, face = \"bold\"),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12),\n        axis.text.x = element_text(size = 12),\n        axis.text.y = element_text(size = 12),\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 12),\n        panel.border = element_rect(colour = \"gray\", fill = NA, linewidth = 0.5))"
  },
  {
    "objectID": "sdms/raster_preparation.html#show-resolution-extent-and-crs-of-raster-and-study-area",
    "href": "sdms/raster_preparation.html#show-resolution-extent-and-crs-of-raster-and-study-area",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "7. Show Resolution, Extent, and CRS of Raster and Study Area",
    "text": "7. Show Resolution, Extent, and CRS of Raster and Study Area\n\n# Get and print the extent of the Australian boundary vector\naustralia_extent &lt;- ext(australia_boundary)\ncat(\"Extent of Australia boundary:\\n\")\n\nExtent of Australia boundary:\n\nprint(australia_extent)\n\nSpatExtent : 96.8169516292395, 167.99803924286, -43.7404965718585, -9.14216252238993 (xmin, xmax, ymin, ymax)\n\n# Get and print the CRS of the Australian boundary vector\naustralia_crs &lt;- crs(australia_boundary)\ncat(\"CRS of Australia boundary:\\n\")\n\nCRS of Australia boundary:\n\nprint(australia_crs)\n\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\n# Iterate over the rasters to show resolution, extent, and CRS\nfor (i in seq_along(rasters)) {\n  cat(\"\\nRaster\", i, \":\\n\")\n\n  # Show the resolution\n  res_val &lt;- res(rasters[[i]])\n  cat(\"Resolution (x, y):\", res_val[1], \",\", res_val[2], \"\\n\")\n\n  # Show the extent - Modified to handle S4 object\n  ext_val &lt;- ext(rasters[[i]])\n  cat(\"Extent:\", as.character(ext_val), \"\\n\") # Convert ext_val to character\n\n  # Show the CRS\n  crs_val &lt;- crs(rasters[[i]])\n  cat(\"CRS:\", crs_val, \"\\n\")\n}\n\n\nRaster 1 :\nResolution (x, y): 0.04166667 , 0.04166667 \nExtent: ext(-180, 180, -90, 90) \nCRS: GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]] \n\nRaster 2 :\nResolution (x, y): 0.04166667 , 0.04166667 \nExtent: ext(-180, 180, -90, 90) \nCRS: GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]] \n\nRaster 3 :\nResolution (x, y): 0.04166667 , 0.04166667 \nExtent: ext(-180, 180, -90, 90) \nCRS: GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]] \n\nRaster 4 :\nResolution (x, y): 0.04166667 , 0.04166667 \nExtent: ext(-180, 180, -90, 90) \nCRS: GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]] \n\nRaster 5 :\nResolution (x, y): 0.04166667 , 0.04166667 \nExtent: ext(-180, 180, -90, 90) \nCRS: GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]] \n\nRaster 6 :\nResolution (x, y): 250 , 250 \nExtent: ext(-2189542.251493, 2468707.748507, -4964936.305317, -1047686.305317) \nCRS: PROJCRS[\"unknown\",\n    BASEGEOGCRS[\"unknown\",\n        DATUM[\"Unknown based on GRS80 ellipsoid\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101004,\n                LENGTHUNIT[\"metre\",1],\n                ID[\"EPSG\",7019]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Albers Equal Area\",\n        METHOD[\"Albers Equal Area\",\n            ID[\"EPSG\",9822]],\n        PARAMETER[\"Latitude of false origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",132,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",-18,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",-36,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
  },
  {
    "objectID": "sdms/raster_preparation.html#reproject-raster-to-wgs-84-if-needed",
    "href": "sdms/raster_preparation.html#reproject-raster-to-wgs-84-if-needed",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "8. Reproject Raster to WGS 84 if Needed",
    "text": "8. Reproject Raster to WGS 84 if Needed\n\nlibrary(terra)\n\n# Function to check CRS and reproject to WGS 84 if needed\nreproject_if_needed &lt;- function(raster, is_categorical = FALSE) {\n  wgs84_crs &lt;- \"EPSG:4326\"  # Define WGS 84 CRS using EPSG code\n\n  # Check if the CRS is already WGS 84\n  if (!identical(crs(raster), wgs84_crs)) {\n    # Choose the appropriate method based on raster type\n    method &lt;- if (is_categorical) \"near\" else \"bilinear\"\n    message(\"Reprojecting raster to WGS 84 using method: \", method)\n\n    # Reproject raster to WGS 84 CRS\n    raster &lt;- project(raster, wgs84_crs, method = method)\n\n    # Convert to factor again if categorical to ensure category levels are preserved\n    if (is_categorical) {\n      raster &lt;- as.factor(raster)\n    }\n  }\n\n  return(raster)\n}\n\n# Define the categorical raster indices\ncategorical_indices &lt;- c(6)  # Adjust if there are other categorical rasters\n\n# Apply the function to each raster in the list\nrasters_reprojected &lt;- lapply(seq_along(rasters), function(i) {\n  is_categorical &lt;- i %in% categorical_indices\n  reproject_if_needed(rasters[[i]], is_categorical = is_categorical)\n})\n\nReprojecting raster to WGS 84 using method: bilinear\nReprojecting raster to WGS 84 using method: bilinear\nReprojecting raster to WGS 84 using method: bilinear\nReprojecting raster to WGS 84 using method: bilinear\nReprojecting raster to WGS 84 using method: bilinear\n\n\nReprojecting raster to WGS 84 using method: near\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# Print the CRS of each reprojected raster to verify\nfor (i in seq_along(rasters_reprojected)) {\n  cat(\"\\nRaster\", i, \"CRS:\\n\")\n  print(crs(rasters_reprojected[[i]]))\n}\n\n\nRaster 1 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nRaster 2 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nRaster 3 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nRaster 4 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nRaster 5 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\nRaster 6 CRS:\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\""
  },
  {
    "objectID": "sdms/raster_preparation.html#resample-rasters-to-match-the-finest-resolution",
    "href": "sdms/raster_preparation.html#resample-rasters-to-match-the-finest-resolution",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "9. Resample Rasters to Match the Finest Resolution",
    "text": "9. Resample Rasters to Match the Finest Resolution\n\n# Determine the finest resolution among the reprojected rasters\nresolutions &lt;- sapply(rasters_reprojected, function(r) res(r)[1] * res(r)[2])\nfinest_index &lt;- which.min(resolutions)\nfinest_raster &lt;- rasters_reprojected[[finest_index]]\n\n# Resample each raster to match the finest resolution\nrasters_resampled &lt;- lapply(seq_along(rasters_reprojected), function(i) {\n  raster &lt;- rasters_reprojected[[i]]\n\n  # Determine resampling method based on the type of raster (categorical vs continuous)\n  if (i == 6) {  # the 6th raster is the categorical one\n    message(\"Resampling categorical raster to match the finest resolution using 'nearest' method.\")\n    raster &lt;- resample(raster, finest_raster, method = \"near\")  # Use 'near' for categorical data\n  } else {\n    message(\"Resampling continuous raster to match the finest resolution using 'bilinear' method.\")\n    raster &lt;- resample(raster, finest_raster, method = \"bilinear\")  # Use 'bilinear' for continuous data\n  }\n\n  return(raster)\n})\n\nResampling continuous raster to match the finest resolution using 'bilinear' method.\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nResampling continuous raster to match the finest resolution using 'bilinear' method.\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nResampling continuous raster to match the finest resolution using 'bilinear' method.\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nResampling continuous raster to match the finest resolution using 'bilinear' method.\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nResampling continuous raster to match the finest resolution using 'bilinear' method.\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nResampling categorical raster to match the finest resolution using 'nearest' method.\n\n\n\n|---------|---------|---------|---------|\n========================================="
  },
  {
    "objectID": "sdms/raster_preparation.html#crop-and-mask-raster-to-study-area",
    "href": "sdms/raster_preparation.html#crop-and-mask-raster-to-study-area",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "10. Crop and Mask Raster to Study Area",
    "text": "10. Crop and Mask Raster to Study Area\n\n# Reproject the Australian boundary vector to WGS 84\nwgs84_crs &lt;- \"EPSG:4326\"\n\naustralia_boundary_vect &lt;- vect(australia_boundary)\n\naustralia_boundary_vect_wgs84 &lt;- project(australia_boundary_vect, wgs84_crs)\n\n# Crop and mask each resampled raster to the extent of Australia\ncropped_masked_rasters &lt;- lapply(rasters_resampled, function(raster) {\n  # Crop the raster to the extent of Australia\n  cropped_raster &lt;- crop(raster, australia_boundary_vect_wgs84)\n  # Mask the raster with the Australia boundary to keep only data within Australia\n  masked_raster &lt;- mask(cropped_raster, australia_boundary_vect_wgs84)\n  return(masked_raster)\n})\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n========================================="
  },
  {
    "objectID": "sdms/raster_preparation.html#stack-and-save-raster",
    "href": "sdms/raster_preparation.html#stack-and-save-raster",
    "title": "Species Distribution Analysis - Environmental Data Preparation (Raster)",
    "section": "11. Stack and Save Raster",
    "text": "11. Stack and Save Raster\n\n# Stack the cropped and masked rasters together\nraster_stack &lt;- do.call(c, cropped_masked_rasters)\n\n# Print summary to verify the stack\nprint(raster_stack)\n\nclass       : SpatRaster \ndimensions  : 14113, 22774, 6  (nrow, ncol, nlyr)\nresolution  : 0.002451532, 0.002451532  (x, y)\nextent      : 105.7046, 161.5358, -43.74011, -9.141636  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsources     : spat_52a0288f180f_21152.tif  \n              spat_52a02c08d10a_21152.tif  \n              spat_52a057cfdb8f_21152.tif  \n              ... and 3 more source(s)\nnames       : env_var_1, env_var_2, env_var_3, env_var_4, env_var_5, Category \nmin values  :  4.272866,  3.591667,  31.50585,  53.13949,  15.60910,        1 \nmax values  : 29.350683, 17.464588,  77.26542, 682.58344,  42.34991,        6 \n\n# Plot each layer to visually verify the raster stack\nplot(raster_stack)\n\n\n\n\n\n\n\n# Save the raster stack to a GeoTIFF file\nwriteRaster(raster_stack, filename = \"stacked_raster.tif\", overwrite = TRUE)\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\n\nEcoCommons Australia partners with the Australian Research Data Commons (ARDC), which is supported by funding from the National Collaborative Research Infrastructure Strategy (NCRIS) https://doi.org/10.47486/PL108.\n\nOur partner"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "EcoCommons Team",
    "section": "",
    "text": "EcoCommons Team"
  },
  {
    "objectID": "models/EC_GLM.html",
    "href": "models/EC_GLM.html",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "",
    "text": "Author details: Abhimanyu Raj Singh and Xiang Zhao\nEditor details: Dr Sebastian Lopez Marcano\nContact details: support@ecocommons.org.au\nCopyright statement: This script is the product of the EcoCommons platform. Please refer to the EcoCommons website for more details: https://www.ecocommons.org.au/\nDate: Oct 2024"
  },
  {
    "objectID": "models/EC_GLM.html#summary",
    "href": "models/EC_GLM.html#summary",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "Summary",
    "text": "Summary\nThe koala (Phascolarctos cinereus), sometimes called the koala bear, is an arboreal herbivorous marsupial native to Australia. It is the only extant representative of the family Phascolarctidae. Its closest living relatives are the wombats. The koala is found in coastal areas of the island’s eastern and southern regions, inhabiting Queensland, New South Wales, Victoria, and South Australia. It is easily recognisable by its stout, tailless body and large head with round, fluffy ears and large, dark nose. The koala has a body length of 60–85 cm (24–33 in) and weighs 4–15 kg (8.8–33.1 lb). Fur colour ranges from silver grey to chocolate brown. Koalas from the northern populations are typically smaller and lighter in colour than their counterparts further south. These populations possibly are separate subspecies, but this is disputed."
  },
  {
    "objectID": "models/EC_GLM.html#set-working-directory-and-make-a-folder-to-store-data.",
    "href": "models/EC_GLM.html#set-working-directory-and-make-a-folder-to-store-data.",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "1. Set working directory and make a folder to store data.",
    "text": "1. Set working directory and make a folder to store data.\n\nworkspace &lt;- getwd()\n\nraw_data_dir &lt;- file.path(workspace, \"raw_data\")\n\n# Create the 'raw_data' directory if it doesn't exist\nif (!dir.exists(raw_data_dir)) {\n  dir.create(raw_data_dir, recursive = TRUE)\n  cat(\"Directory 'raw_data' created successfully.\\n\")\n} else {\n  cat(\"Directory 'raw_data' already exists.\\n\")\n}\n\nDirectory 'raw_data' already exists.\n\n# Increase the plot size by changing the options for the plot dimensions\noptions(repr.plot.width = 16, repr.plot.height = 8)  # This will make the plot larger in the notebook output"
  },
  {
    "objectID": "models/EC_GLM.html#install-and-load-essential-libraries.",
    "href": "models/EC_GLM.html#install-and-load-essential-libraries.",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "2. Install and load essential libraries.",
    "text": "2. Install and load essential libraries.\n\n# List of packages to check, install if needed, and load\npackages &lt;- c(\"dplyr\", \"terra\", \"sf\", \"googledrive\", \"ggplot2\", \"corrplot\", \"pROC\", \"ROSE\")\n\n# Install missing packages and load them\nfor (pkg in packages) {\n  if (!requireNamespace(pkg, quietly = TRUE)) {\n    install.packages(pkg)\n  }\n  library(pkg, character.only = TRUE)\n}\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nterra 1.7.78\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\ncorrplot 0.95 loaded\n\n\nType 'citation(\"pROC\")' for a citation.\n\n\n\nAttaching package: 'pROC'\n\n\nThe following objects are masked from 'package:stats':\n\n    cov, smooth, var\n\n\nLoaded ROSE 0.0-4"
  },
  {
    "objectID": "models/EC_GLM.html#get-data-from-ecocommons-public-google-drive",
    "href": "models/EC_GLM.html#get-data-from-ecocommons-public-google-drive",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "1. Get data from EcoCommons Public Google drive",
    "text": "1. Get data from EcoCommons Public Google drive\n\nlibrary(googledrive)\n\n# De-authenticate Google Drive to access public files\ndrive_deauth()\n\n# Define Google Drive file IDs and corresponding local file paths for environmental variables\nfile_ids &lt;- list(\n  csv = \"13wnlQvnAqtml-_MUY6iIZe7LabrrhQCX\", # Koala data\n  env_var_stack = \"1ES0UbTDKSKyQ7PpM8eFN59R8xOYuDgrC\" # environmental variables\n)\n\n# Define local file paths for each environmental variable\nfile_paths &lt;- list(\n  csv = file.path(workspace, \"raw_data\", \"koala.csv\"),\n  env_var_stack = file.path(workspace, \"raw_data\", \"env_var_stack.tif\")\n)\n\n# Function to download individual files with progress messages\ndownload_file &lt;- function(file_id, file_path) {\n  cat(\"Downloading:\", basename(file_path), \"...\\n\")\n  drive_download(as_id(file_id), path = file_path, overwrite = TRUE)\n  cat(\"Downloaded:\", basename(file_path), \"\\n\")\n}\n\n# Download each environmental variable file\ncat(\"Downloading environmental variable files...\\n\")\n\nDownloading environmental variable files...\n\ninvisible(mapply(download_file, file_ids, file_paths))\n\nDownloading: koala.csv ...\n\n\nFile downloaded:\n\n\n• 'koala_ala.csv' &lt;id: 13wnlQvnAqtml-_MUY6iIZe7LabrrhQCX&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/koala.csv'\n\n\nDownloaded: koala.csv \nDownloading: env_var_stack.tif ...\n\n\nFile downloaded:\n\n\n• 'stacked_env_raster.tif' &lt;id: 1ES0UbTDKSKyQ7PpM8eFN59R8xOYuDgrC&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/env_var_stack.tif'\n\n\nDownloaded: env_var_stack.tif \n\n# Confirm the files have been downloaded\ndownloaded_files &lt;- list.files(file.path(workspace, \"raw_data\"), recursive = TRUE)\ncat(\"Downloaded files:\\n\", downloaded_files, \"\\n\")\n\nDownloaded files:\n aus_shapefile/AUS_2021_AUST_GDA2020.dbf aus_shapefile/AUS_2021_AUST_GDA2020.prj aus_shapefile/AUS_2021_AUST_GDA2020.shp aus_shapefile/AUS_2021_AUST_GDA2020.shx aus_shapefile/AUS_2021_AUST_GDA2020.xml env_var_stack.tif koala.csv \n\n\n\nlibrary(googledrive)\n\n# De-authenticate Google Drive to access public files\ndrive_deauth()\n\n# Folder ID for the Australian polygon shapefile\naus_folder_id &lt;- \"1rzNHthnQQXVulocKkB5i7v2dObqKMP11\"\n\n# Define the local directory to save the shapefile components\nshapefile_dir &lt;- file.path(workspace, \"raw_data\", \"aus_shapefile\")\ndir.create(shapefile_dir, showWarnings = FALSE, recursive = TRUE)\n\n# List all files in the shapefile folder on Google Drive\nfiles_in_folder &lt;- drive_ls(as_id(aus_folder_id))\n\n# Download each file in the folder\ncat(\"Downloading shapefile components...\\n\")\n\nDownloading shapefile components...\n\nfor (i in 1:nrow(files_in_folder)) {\n  file_name &lt;- files_in_folder$name[i]\n  cat(\"Downloading:\", file_name, \"...\\n\")\n  drive_download(files_in_folder$id[i], path = file.path(shapefile_dir, file_name), overwrite = TRUE)\n}\n\nDownloading: AUS_2021_AUST_GDA2020.xml ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.xml' &lt;id: 1BxMyIxENdWJ2RiZxK_8Ay_0r2Uvad5Wd&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.xml'\n\n\nDownloading: AUS_2021_AUST_GDA2020.shx ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.shx' &lt;id: 1wfSxFsmgK4V44f4ZJhYy3V6wL16YpVWe&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.shx'\n\n\nDownloading: AUS_2021_AUST_GDA2020.dbf ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.dbf' &lt;id: 1gdWxQ5aOB_KuejlHn254K7RwdtDR2N8f&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.dbf'\n\n\nDownloading: AUS_2021_AUST_GDA2020.prj ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.prj' &lt;id: 1Fi9K9mWOpvksSkH0CGJN9XlKf8-1LjSj&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.prj'\n\n\nDownloading: AUS_2021_AUST_GDA2020.shp ...\n\n\nFile downloaded:\n\n\n• 'AUS_2021_AUST_GDA2020.shp' &lt;id: 1ZWGQYHbygM-MCFyON76FXwj7uHwJnpxH&gt;\n\n\nSaved locally as:\n\n\n• '/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.shp'\n\ncat(\"Shapefile components downloaded to:\", shapefile_dir, \"\\n\")\n\nShapefile components downloaded to: /Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile"
  },
  {
    "objectID": "models/EC_GLM.html#define-study-area",
    "href": "models/EC_GLM.html#define-study-area",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "2. Define Study Area",
    "text": "2. Define Study Area\nAll raster files are loaded and reprojected if necessary to ensure consistency.\n\nlibrary(sf)\nlibrary(terra)\nlibrary(ggplot2)\n\n# Define the path to the Australian shapefile's .shp component\nshapefile_path &lt;- file.path(workspace, \"raw_data\", \"aus_shapefile\", \"AUS_2021_AUST_GDA2020.shp\")\n\n# Load the Australian boundary as an sf object and convert to EPSG 4326\naustralia_boundary &lt;- st_read(shapefile_path)\n\nReading layer `AUS_2021_AUST_GDA2020' from data source \n  `/Users/zhaoxiang/Documents/tmp/test/notebook-blog/models/raw_data/aus_shapefile/AUS_2021_AUST_GDA2020.shp' \n  using driver `ESRI Shapefile'\nreplacing null geometries with empty geometries\nSimple feature collection with 2 features and 6 fields (with 1 geometry empty)\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.81695 ymin: -43.7405 xmax: 167.998 ymax: -9.142163\nGeodetic CRS:  GDA2020\n\naustralia_boundary &lt;- st_transform(australia_boundary, crs = 4326)\n\n# Convert the sf object to a SpatVector for terra operations, if needed\naustralia_boundary_vect &lt;- vect(australia_boundary)\n\n# Plot the Australia boundary using ggplot2\nggplot(data = australia_boundary) +\n  geom_sf(fill = \"#61c6fa\", color = \"black\") +  # Fill with light blue and outline in black\n  labs(title = \"Map of Australia\") +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 18, face = \"bold\"),\n        axis.title.x = element_text(size = 12),\n        axis.title.y = element_text(size = 12),\n        axis.text.x = element_text(size = 12),\n        axis.text.y = element_text(size = 12),\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 12),\n        panel.border = element_rect(colour = \"gray\", fill = NA, linewidth = 0.5))"
  },
  {
    "objectID": "models/EC_GLM.html#species-occurrence-data-prep-and-check",
    "href": "models/EC_GLM.html#species-occurrence-data-prep-and-check",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "3. Species Occurrence Data Prep and check",
    "text": "3. Species Occurrence Data Prep and check\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Read the koala data\nkoala_path &lt;- file.path(workspace, \"raw_data\", \"koala.csv\")\nkoala_data &lt;- read.csv(koala_path)\n\n# Filter rows without missing values in coordinates\nkoala_data_clean &lt;- koala_data %&gt;%\n  filter(!is.na(decimalLongitude), !is.na(decimalLatitude))\n\n# Convert the koala data to an sf object using \"decimalLongitude\" and \"decimalLatitude\"\nkoala_sf &lt;- st_as_sf(koala_data_clean, coords = c(\"decimalLongitude\", \"decimalLatitude\"), crs = 4326)\n\n# Define the bounding box\nbbox &lt;- st_bbox(c(xmin = 96.81695, ymin = -43.7405, xmax = 167.998, ymax = -9.142163), crs = st_crs(koala_sf))\n\n# Convert the bbox to an sfc object\nbbox_sfc &lt;- st_as_sfc(bbox)\n\n# Filter koala points that fall within the bounding box\nkoala_sf_au &lt;- koala_sf[st_within(koala_sf, bbox_sfc, sparse = FALSE), ]\n\n# View filtered points\nprint(koala_sf_au)\n\nSimple feature collection with 244474 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 115.6839 ymin: -39.1295 xmax: 154 ymax: -15.4\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   occurrenceStatus                   geometry\n1           PRESENT POINT (138.7069 -34.91539)\n2           PRESENT POINT (138.8452 -35.19909)\n3           PRESENT POINT (138.7268 -34.91561)\n4           PRESENT POINT (138.7688 -34.96979)\n5           PRESENT POINT (138.6979 -34.96306)\n6           PRESENT POINT (138.7317 -34.92928)\n7           PRESENT POINT (138.5654 -34.93541)\n8           PRESENT POINT (138.6774 -35.02592)\n9           PRESENT  POINT (138.7089 -34.9585)\n10           ABSENT  POINT (138.6245 -34.9807)\n\n# Replace \"PRESENT\" with 1 and \"ABSENT\" with 0 in the occurrenceStatus column\nkoala_sf_au$occurrenceStatus &lt;- ifelse(koala_sf_au$occurrenceStatus == \"PRESENT\", 1, 0)\n\n# Convert occurrenceStatus to a factor\nkoala_sf_au$occurrenceStatus &lt;- factor(koala_sf_au$occurrenceStatus, levels = c(0, 1))\n\n# View updated koala data\nprint(koala_sf_au)\n\nSimple feature collection with 244474 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 115.6839 ymin: -39.1295 xmax: 154 ymax: -15.4\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   occurrenceStatus                   geometry\n1                 1 POINT (138.7069 -34.91539)\n2                 1 POINT (138.8452 -35.19909)\n3                 1 POINT (138.7268 -34.91561)\n4                 1 POINT (138.7688 -34.96979)\n5                 1 POINT (138.6979 -34.96306)\n6                 1 POINT (138.7317 -34.92928)\n7                 1 POINT (138.5654 -34.93541)\n8                 1 POINT (138.6774 -35.02592)\n9                 1  POINT (138.7089 -34.9585)\n10                0  POINT (138.6245 -34.9807)\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Calculate counts for presence and absence\nkoala_counts &lt;- koala_sf_au %&gt;%\n  dplyr::count(occurrenceStatus)\n\n# Create labels for the legend that include counts\nlegend_labels &lt;- c(\n  \"0\" = paste0(\"ABSENT: \", koala_counts$n[koala_counts$occurrenceStatus == 0]),\n  \"1\" = paste0(\"PRESENT: \", koala_counts$n[koala_counts$occurrenceStatus == 1])\n)\n\n\n# Plotting\nggplot(data = australia_boundary) +\n  geom_sf(fill = \"#61c6fa\", color = \"black\") +  # Australia map fill and outline color\n  geom_sf(data = koala_sf_au, aes(color = occurrenceStatus), size = 2) +  # Koala presences and absences points\n  scale_color_manual(values = c(\"0\" = \"#f6aa70\", \"1\" = \"#11aa96\"),  # Colors for absence (0) and presence (1)\n                     labels = legend_labels) +  # Labels for legend including counts\n  labs(title = \"Koala Presences and Absences in Australia\", color = \"Occurrence Status\") +  # Title and legend title\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 18, face = \"bold\"),\n    axis.text.x = element_text(size = 12),\n    axis.text.y = element_text(size = 12),\n    legend.text = element_text(size = 12),\n    panel.border = element_rect(colour = \"gray\", fill = NA, linewidth = 0.5),\n    legend.position.inside = c(0.8, 0.2),  # Adjusted legend position for full map\n    legend.justification = c(0, 1)\n  )"
  },
  {
    "objectID": "models/EC_GLM.html#environmental-variables-prep-and-check",
    "href": "models/EC_GLM.html#environmental-variables-prep-and-check",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "4. Environmental Variables Prep and check",
    "text": "4. Environmental Variables Prep and check\nSince the extents of the enviromental variables 1 to 5 are world wide, we need to crop it to the extent of our study area, that is Australia. And we want to make sure the coordinate system of each of the variable is EPSG:4326.\n\nstack_file_path &lt;- file.path(workspace, \"raw_data\", \"env_var_stack.tif\")\n\nraster_stack &lt;- rast(stack_file_path)\n\nprint(names(raster_stack))\n\n[1] \"env_var_1\" \"env_var_2\" \"env_var_3\" \"env_var_4\" \"env_var_5\" \"Category\" \n\n# Load the raster stack\nstack_file_path &lt;- file.path(workspace, \"raw_data\", \"env_var_stack.tif\")\nraster_stack &lt;- rast(stack_file_path)\n\n# Assign new names to the first five layers\nlayer_names &lt;- c(\n  \"env_var_1\", #   \"Bioclim 01: Annual Mean Temperature\",\n  \"env_var_2\", #   \"Bioclim 02: Mean Diurnal Range\",\n  \"env_var_3\", #   \"Bioclim 03: Isothermality\",\n  \"env_var_4\", #   \"Bioclim 04: Temperature Seasonality\",\n  \"env_var_5\", #   \"Bioclim 05: \",\n  \"env_cat_var_1\" # \"Six class of land use of Australia\",\n)\n\nnames(raster_stack)[1:6] &lt;- layer_names\n\n# Factorize the sixth raster layer\nraster_stack[[6]] &lt;- as.factor(raster_stack[[6]])\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# Verify the names\nprint(raster_stack)\n\nclass       : SpatRaster \ndimensions  : 14113, 22774, 6  (nrow, ncol, nlyr)\nresolution  : 0.002451532, 0.002451532  (x, y)\nextent      : 105.7046, 161.5358, -43.74011, -9.141636  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsources     : env_var_stack.tif  (5 layers) \n              env_var_stack.tif  \nnames       : env_var_1, env_var_2, env_var_3, env_var_4, env_var_5, env_c~var_1 \nmin values  :  4.272866,  3.591667,  31.50585,  53.13949,  15.60910,           1 \nmax values  : 29.350683, 17.464588,  77.26542, 682.58344,  42.34991,           6 \n\n\n\n# Plot the masked raster\nplot(raster_stack[[1]],\n     main = \"Bioclim 01: Annual Mean Temperature\",\n     col = terrain.colors(20),\n     xlab = \"Longitude\",\n     ylab = \"Latitude\",\n     cex.main = 1.5,\n     cex.lab = 1.2,\n     cex.axis = 1)\n\n\n\n\n\n\n\n\n\n# Plot the masked raster\nplot(raster_stack[[2]],\n     main = \"Bioclim 02: Mean Diurnal Range\",\n     col = terrain.colors(20),\n     xlab = \"Longitude\",\n     ylab = \"Latitude\",\n     cex.main = 1.5,\n     cex.lab = 1.2,\n     cex.axis = 1)\n\n\n\n\n\n\n\n\n\n# Plot the masked raster\nplot(raster_stack[[3]],\n     main = \"Bioclim 03: Isothermality\",\n     col = terrain.colors(20),\n     xlab = \"Longitude\",\n     ylab = \"Latitude\",\n     cex.main = 1.5,\n     cex.lab = 1.2,\n     cex.axis = 1)\n\n\n\n\n\n\n\n\n\n# Plot the masked raster\nplot(raster_stack[[4]],\n     main = \"Bioclim 04: Temperature Seasonality\",\n     col = terrain.colors(20),\n     xlab = \"Longitude\",\n     ylab = \"Latitude\",\n     cex.main = 1.5,\n     cex.lab = 1.2,\n     cex.axis = 1)\n\n\n\n\n\n\n\n\n\n# Plot the masked raster\nplot(raster_stack[[5]],\n     main = \"Bioclim 05: Max Temperature of Warmest Month\",\n     col = terrain.colors(20),\n     xlab = \"Longitude\",\n     ylab = \"Latitude\",\n     cex.main = 1.5,\n     cex.lab = 1.2,\n     cex.axis = 1)\n\n\n\n\n\n\n\n\n\n# Set color palette and categories\ncolor_palette &lt;- c(\"#CA7AF5\", \"#FFFFBE\", \"#FFAA00\", \"#734C00\", \"#FF0000\", \"#0000FF\")\ncolor_category &lt;- c(\"Conservation\",\n                    \"Production Natural\",\n                    \"Dryland Agriculture\",\n                    \"Irrigated Agriculture\",\n                    \"Intensive Uses\",\n                    \"Water\")\n\n# Set up layout with more space for the main plot and a smaller area for the legend\nlayout(matrix(c(1, 2), nrow = 1), widths = c(7, 3))  # Allocate 7:3 space for the main plot and legend\n\n# Increase the plot size by changing the options for the plot dimensions\noptions(repr.plot.width = 16, repr.plot.height = 8)  # This will make the plot larger in the notebook output\n\n# Increase the margins for the main plot to make it visually balanced\npar(mar = c(5, 4, 4, 1), cex.axis = 1.5, cex.lab = 1.5, cex.main = 2)  # Adjust margin and text sizes\n\n# Plot the reclassified raster without the legend or color bar\nplot(raster_stack[[6]], col = color_palette, main = \"Land Use of Australia\",\n     legend = FALSE, axes = TRUE, xlab = \"Longitude\", ylab = \"Latitude\")\n\n# Set margins for the legend plot area and create enough space to avoid overlap\npar(mar = c(5, 1, 4, 1))  # Minimal margins for the legend area\nplot.new()  # Create a blank plot for the legend\n\n# Add a custom legend with colors and category labels, placed on the left\nlegend(\"left\", legend = color_category, fill = color_palette,\n       title = \"Land Use Categories\", cex = 1.2, bty = \"n\", xpd = TRUE)"
  },
  {
    "objectID": "models/EC_GLM.html#combine-data-for-the-model",
    "href": "models/EC_GLM.html#combine-data-for-the-model",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "5. Combine data for the model",
    "text": "5. Combine data for the model\n\n# For the fisrt five continuous environmental variables, we extract their values and combine them with the species presence and absence data\n\n# Convert occurrence points to a SpatVector to work with terra package\noccurrence_points &lt;- vect(koala_sf_au)\n\n# Initialize an empty list to store the extracted values for the first five raster layers\nextracted_values_list &lt;- list()\n\n# Extract values for the first five environmental layers\nfor (i in 1:5) {\n  # Extract values from the current raster layer\n  extracted_values &lt;- extract(raster_stack[[i]], occurrence_points)[, 2]  # Extracts values, removes ID column\n  # Append the extracted values to the list\n  extracted_values_list[[i]] &lt;- extracted_values\n}\n\n\n# Combine all extracted values into a dataframe\nextracted_values_df &lt;- as.data.frame(extracted_values_list)\n\n# Set appropriate column names for the extracted environmental variables\nnames(extracted_values_df) &lt;- paste0(\"env_var_\", 1:5)\n\n# Combine coordinates and occurrence data with the extracted values\ncoordinates &lt;- st_coordinates(koala_sf_au)\noccurrence_data &lt;- as.data.frame(koala_sf_au)\n\n# Combine all into a single dataframe\nmodel_data_df &lt;- data.frame(coordinates, occurrence_data, extracted_values_df)\n\n# Rename columns for better readability\nnames(model_data_df)[1:2] &lt;- c(\"Longitude\", \"Latitude\")\n\n# View the first few rows of the resulting dataframe\nhead(model_data_df)\n\n  Longitude  Latitude occurrenceStatus                   geometry env_var_1\n1  138.7069 -34.91539                1 POINT (138.7069 -34.91539)  14.54203\n2  138.8452 -35.19909                1 POINT (138.8452 -35.19909)  14.81205\n3  138.7268 -34.91561                1 POINT (138.7268 -34.91561)  13.87424\n4  138.7688 -34.96979                1 POINT (138.7688 -34.96979)  13.51479\n5  138.6979 -34.96306                1 POINT (138.6979 -34.96306)  13.86197\n6  138.7317 -34.92928                1 POINT (138.7317 -34.92928)  13.63266\n  env_var_2 env_var_3 env_var_4 env_var_5\n1  9.237247  45.22653  394.6680  26.39647\n2 10.868230  49.83393  393.5269  27.62096\n3  8.927568  44.39176  392.4944  25.75511\n4  9.147509  45.01126  389.9970  25.71477\n5  8.786623  44.35983  386.4311  25.53398\n6  8.823922  44.17895  390.7072  25.50289\n\n\n\n# Extract values for the sixth environmental variable\nenv_var_6_values &lt;- extract(raster_stack[[6]], occurrence_points)[, 2]  # Extracts values, removes ID column\n\n# Convert the extracted values to a factor (if not already)\nenv_var_6_values &lt;- as.factor(env_var_6_values)\n\n\n# Add the extracted factor variable to model_data_df\nmodel_data_df$env_cat_var_1 &lt;- env_var_6_values\n\nmodel_data_df &lt;- na.omit(model_data_df) # we need to remove rows containing NA\n\n# View the first few rows of the resulting dataframe\nhead(model_data_df)\n\n  Longitude  Latitude occurrenceStatus                   geometry env_var_1\n1  138.7069 -34.91539                1 POINT (138.7069 -34.91539)  14.54203\n2  138.8452 -35.19909                1 POINT (138.8452 -35.19909)  14.81205\n3  138.7268 -34.91561                1 POINT (138.7268 -34.91561)  13.87424\n4  138.7688 -34.96979                1 POINT (138.7688 -34.96979)  13.51479\n5  138.6979 -34.96306                1 POINT (138.6979 -34.96306)  13.86197\n6  138.7317 -34.92928                1 POINT (138.7317 -34.92928)  13.63266\n  env_var_2 env_var_3 env_var_4 env_var_5 env_cat_var_1\n1  9.237247  45.22653  394.6680  26.39647             5\n2 10.868230  49.83393  393.5269  27.62096             2\n3  8.927568  44.39176  392.4944  25.75511             2\n4  9.147509  45.01126  389.9970  25.71477             5\n5  8.786623  44.35983  386.4311  25.53398             1\n6  8.823922  44.17895  390.7072  25.50289             5\n\n\nThe number of absence of koala is 1958, the number of presence of koala is 242516, which is very unbalanced. We want to use oversampling method to make some pesudo absence data to add to the koala data to make 0 and 1 balanced.\nNumber of Additional Absence Records Needed: 242 , 516 − 1 , 958 = 240 , 558 242,516−1,958=240,558"
  },
  {
    "objectID": "models/EC_GLM.html#test-collinearity-among-continuous-variables",
    "href": "models/EC_GLM.html#test-collinearity-among-continuous-variables",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "6. Test Collinearity among continuous variables",
    "text": "6. Test Collinearity among continuous variables\nTesting for collinearity among continuous variables is an important step in many modeling processes, particularly in species distribution modeling and other regression-based analyses. Collinearity occurs when two or more predictor variables in a dataset are highly correlated, which can lead to unstable estimates of regression coefficients and make it difficult to interpret the results.\nThere are two common methods for testing collinearity among continous variables.\nBefore fitting the mode, we can use correlation matrix\n\n# Load necessary library\nlibrary(corrplot)\n\n# Calculate the correlation matrix for the first five continuous variables\ncor_matrix &lt;- cor(model_data_df[, c(\"env_var_1\", \"env_var_2\", \"env_var_3\", \"env_var_4\", \"env_var_5\")],\n                  use = \"complete.obs\", method = \"pearson\")\nprint(cor_matrix)\n\n           env_var_1 env_var_2   env_var_3   env_var_4 env_var_5\nenv_var_1  1.0000000 0.1105075  0.57999411 -0.24165067 0.8063172\nenv_var_2  0.1105075 1.0000000  0.57716220  0.74838666 0.6092138\nenv_var_3  0.5799941 0.5771622  1.00000000 -0.07462366 0.6320608\nenv_var_4 -0.2416507 0.7483867 -0.07462366  1.00000000 0.2924541\nenv_var_5  0.8063172 0.6092138  0.63206081  0.29245415 1.0000000\n\n# Visualize the correlation matrix using corrplot\ncorrplot(cor_matrix,\n         method = \"color\",          # Use colored squares to represent correlation strength\n         type = \"upper\",            # Only show the upper triangle of the matrix\n         order = \"hclust\",          # Reorder the variables based on hierarchical clustering\n         addCoef.col = \"black\",     # Add correlation coefficients in black\n         tl.col = \"black\",          # Text labels color\n         tl.srt = 45,               # Rotate text labels for better readability\n         diag = FALSE)              # Hide the diagonal\n\n\n\n\n\n\n\n\nFrom the above corrplot, we can find:\nThere are some strong correlations present, notably between env_var_1 and env_var_5 (0.878) and env_var_2 and env_var_3 (0.817). This indicates potential collinearity, which could be problematic for certain modeling approaches, as it can affect the stability of model parameters.\nWe don’t have to include env_var_2 and env_var_5 in model anymore.\n\n# Remove \"env_var_2\" and \"env_var_5\" by specifying their negative index\nmodel_data_df &lt;- model_data_df[, !names(model_data_df) %in% c(\"env_var_2\", \"env_var_5\")]"
  },
  {
    "objectID": "models/EC_GLM.html#dealing-with-unbalanced-dataset",
    "href": "models/EC_GLM.html#dealing-with-unbalanced-dataset",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "7. Dealing with unbalanced dataset",
    "text": "7. Dealing with unbalanced dataset\nSince our koala absences are too few comparing with the presences, we need to use resamping tehniques to increase the koala absences in the dataset to make it even.\n\n# Calculate counts for presence and absence\nprint(koala_counts)\n\nSimple feature collection with 2 features and 2 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 115.6839 ymin: -39.1295 xmax: 154 ymax: -15.4\nGeodetic CRS:  WGS 84\n  occurrenceStatus      n                       geometry\n1                0   1958 MULTIPOINT ((146.8646 -19.1...\n2                1 242516 MULTIPOINT ((135 -31), (134...\n\n\n\nlibrary(ROSE)\n\n# Balance the dataset using oversampling for absences\nbalanced_data &lt;- ovun.sample(\n  occurrenceStatus ~ env_var_1 + env_var_3 + env_var_4 + env_cat_var_1,\n  data = model_data_df,\n  method = \"over\",\n  N = 2 * 242516  # Total desired sample size: equal number of 0 and 1\n)$data\n\n# Verify the balance of the dataset\ntable(balanced_data$occurrenceStatus)\n\n\n     1      0 \n242148 242884 \n\n\nNow, our 0s and 1s look very even."
  },
  {
    "objectID": "models/EC_GLM.html#split-data-into-training-dataset-80-and-testing-dataset-20",
    "href": "models/EC_GLM.html#split-data-into-training-dataset-80-and-testing-dataset-20",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "8. Split data into training dataset (80%) and testing dataset (20%)",
    "text": "8. Split data into training dataset (80%) and testing dataset (20%)\n\n## 80% of the species occurrence data\nsmp_size &lt;- floor(0.8 * nrow(balanced_data))\n\n## set the seed to make your partition reproducible\nset.seed(123)\ntrain_ind &lt;- sample(seq_len(nrow(balanced_data)), size = smp_size)\n\ntraining_df &lt;- balanced_data[train_ind, ]\ntesting_df &lt;- balanced_data[-train_ind, ]"
  },
  {
    "objectID": "models/EC_GLM.html#model-configuration",
    "href": "models/EC_GLM.html#model-configuration",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "1. Model Configuration",
    "text": "1. Model Configuration\nWe are fitting a logistic regression model using 3 continuous environmental variables and one categorical variable as predictors with the testing dataset.\n\n# Let's make a null model as a benchmark\n\n# Fit a null model with only the intercept\nnull_model &lt;- glm(occurrenceStatus ~ 1,\n                  data = training_df,\n                  family = binomial(link = \"logit\"))\n\nsummary(null_model)\n\n\nCall:\nglm(formula = occurrenceStatus ~ 1, family = binomial(link = \"logit\"), \n    data = training_df)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept) 0.002232   0.003211   0.695    0.487\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 537916  on 388024  degrees of freedom\nResidual deviance: 537916  on 388024  degrees of freedom\nAIC: 537918\n\nNumber of Fisher Scoring iterations: 3\n\n\n\n# Fit a logistic regression model with presence (binary response)\nglm_model &lt;- glm(occurrenceStatus ~ env_var_1 + env_var_3 + env_var_4 + env_cat_var_1,\n                 data = training_df,\n                 family = binomial(link = \"logit\")) #in the Generalized Linear Model (GLM), setting family = binomial(link = \"logit\") is appropriate when dealing with binary outcomes such as presence (1) and absence (0) of an event, which, in this case, is the occurrence of tree kangaroos.\n\n# Summary of the model to view the results\nsummary(glm_model)\n\n\nCall:\nglm(formula = occurrenceStatus ~ env_var_1 + env_var_3 + env_var_4 + \n    env_cat_var_1, family = binomial(link = \"logit\"), data = training_df)\n\nCoefficients:\n                 Estimate Std. Error  z value Pr(&gt;|z|)    \n(Intercept)     2.251e+01  1.027e-01  219.254  &lt; 2e-16 ***\nenv_var_1      -1.451e-01  2.271e-03  -63.916  &lt; 2e-16 ***\nenv_var_3      -4.191e-01  2.458e-03 -170.473  &lt; 2e-16 ***\nenv_var_4      -8.783e-04  9.877e-05   -8.892  &lt; 2e-16 ***\nenv_cat_var_12 -3.076e-01  1.641e-02  -18.740  &lt; 2e-16 ***\nenv_cat_var_13  1.519e+00  1.948e-02   77.996  &lt; 2e-16 ***\nenv_cat_var_14  1.832e+00  5.783e-02   31.684  &lt; 2e-16 ***\nenv_cat_var_15  2.947e-01  9.343e-03   31.545  &lt; 2e-16 ***\nenv_cat_var_16 -1.199e-01  2.517e-02   -4.764  1.9e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 537916  on 388024  degrees of freedom\nResidual deviance: 402106  on 388016  degrees of freedom\nAIC: 402124\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n# Let's compare the performance of our model to a null model\n\n# Compare null model with full model using the analysis of deviance (Likelihood Ratio Test)\nanova(null_model, glm_model, test = \"Chisq\")\n\nAnalysis of Deviance Table\n\nModel 1: occurrenceStatus ~ 1\nModel 2: occurrenceStatus ~ env_var_1 + env_var_3 + env_var_4 + env_cat_var_1\n  Resid. Df Resid. Dev Df Deviance  Pr(&gt;Chi)    \n1    388024     537916                          \n2    388016     402106  8   135811 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# Compare the AIC of the null model and the full model\nAIC(null_model, glm_model)\n\n           df      AIC\nnull_model  1 537918.4\nglm_model   9 402123.8\n\n# Get the null deviance and residual deviance from the full model\nnull_deviance &lt;- glm_model$null.deviance\nresidual_deviance &lt;- glm_model$deviance\n\n# Calculate the deviance explained\ndeviance_explained &lt;- (null_deviance - residual_deviance) / null_deviance\n\n# Print the deviance explained as a percentage\ndeviance_explained_percent &lt;- deviance_explained * 100\ncat(\"Deviance Explained:\", deviance_explained_percent, \"%\\n\")\n\nDeviance Explained: 25.24752 %\n\n\n\nSummary of Interpretation\nThe Likelihood Ratio Test (ANOVA) shows that adding the predictors significantly improved the model’s fit compared to the null model, as indicated by the high deviance reduction and a p-value of 0.\nThe AIC for the full model is much lower than the null model, further indicating a better fit when balancing model complexity.\nThe Deviance Explained of 25.34% suggests that the full model explains about a quarter of the variability in koala presence/absence, indicating that while the predictors contribute useful information, there is still substantial unexplained variability that may require further investigation or additional predictors."
  },
  {
    "objectID": "models/EC_GLM.html#model-evaluation",
    "href": "models/EC_GLM.html#model-evaluation",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "2. Model evaluation",
    "text": "2. Model evaluation\nNow, we use the testing dataset to evaluate the model performance.\n\n# Predict on the testing data\npredicted_probs &lt;- predict(glm_model, newdata = testing_df, type = \"response\")\n\n# Convert probabilities to binary predictions (using a threshold of 0.5)\npredicted_classes &lt;- ifelse(predicted_probs &gt; 0.5, 1, 0)\n\nlibrary(pROC)\n\n# Create an ROC curve and compute AUC\nroc_curve &lt;- roc(testing_df$occurrenceStatus, predicted_probs)\n\nSetting levels: control = 1, case = 0\n\n\nSetting direction: controls &lt; cases\n\nauc_value &lt;- auc(roc_curve)\nprint(auc_value)\n\nArea under the curve: 0.8366\n\n# Plot the ROC curve\nplot(roc_curve, main = paste(\"ROC Curve (AUC =\", round(auc_value, 2), \")\"))"
  },
  {
    "objectID": "models/EC_GLM.html#predictions-on-current-environment",
    "href": "models/EC_GLM.html#predictions-on-current-environment",
    "title": "Species Distribution Analysis - Generalized Linear Model (GLM)",
    "section": "1. Predictions on Current Environment",
    "text": "1. Predictions on Current Environment\n\n# Predict the presence probability across the entire raster extent\npredicted_raster &lt;- predict(raster_stack, glm_model, type = \"response\")\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# Plot the predicted raster to visualize the results\nplot(predicted_raster, main = \"Predicted Probability of Presence\")"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html",
    "href": "sp/ecocommons-marxan-integration-poc.html",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Author: Zhao Xiang, EcoCommons\nDate: 2024-10-02\n\n\n\n\n\n\n\nUsing the Species distribution modeling techniques provided by the EcoCommons Platform (www.ecocommons.org.au), we produced probability distribution maps for the three Queensland endangered species: koala, brush tailed rock-wallaby, and beach stone curlew.\nThen we adjusted the probability distribution maps of these three species with the planning units shapefile prepared by the Marxan MaPP, and ran four planning scenarios with a target of expanding the coverage of protected areas in QLD to 30%.\n\n\n\n\nSpecies records pulled from GBIF, ALA, EcoPlots, OBIS\nSpecies distribution modelling output: Species distribution Probability maps (This is the input tested in this project).\n\n\n\n\n\nShapefile of planning area and units.\nShapefile of cost.\nShapefile and csv of biodiversity features (Where EcoCommons can help!).\n\n\n\n\nMake sure you are in the directory you want\n\ngetwd()\n\n[1] \"/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sp\"\n\n# setwd(“/replace_this_with_your_actual_directory/ecocommons-marxan-integration-poc”)\n\nActivate the virtual environment “renv” to install and load all essential packages\n\n# install \"renv\" package if not been installed\nif (!requireNamespace(\"renv\", quietly = TRUE)) {\n  install.packages(\"renv\")\n}\n\nif (!file.exists(\"renv/activate.R\")) {\n   message(\"renv has not been initiated in this project. Initializing now...\")\n   renv::init()  # This initializes renv if it's not set up\n} else {\n   source(\"renv/activate.R\")  # This ensures the renv environment is activated\n   message(\"renv is activated.\")\n}\n\n# Ensure renv is installed and initialized\nif (file.exists(\"renv.lock\")) {\n  renv::restore()\n} else {\n  message(\"No renv.lock file found in the current directory.\")\n}\n\nInstall and load essential packages\n\n# Set CRAN mirror\noptions(repos = c(CRAN = \"https://cran.rstudio.com/\"))\n\n# First specify the packages of interest\npackages = c(\"shiny\", \"sf\", \"terra\", \"ggplot2\", \"ggspatial\", \"raster\", \"dplyr\", \"shiny\", \"httpuv\", \"rmarkdown\", \"knitr\", \"jsonlite\", \"reticulate\", \"htmltools\", \"pryr\")\n\n# Now load or install&load all. This process will take a long time since we are using a virtual environment and install a lot of packages.\npackage.check &lt;- lapply(\n  packages,\n  FUN = function(x) {\n    if (!require(x, character.only = TRUE)) {\n      install.packages(x, dependencies = TRUE)\n      library(x, character.only = TRUE)\n     }\n  }\n )\n\n\nSys.setenv(PROJ_LIB = \"/usr/local/Cellar/proj/9.5.0/share/proj\")\n\nrenv::snapshot()\n\n1. We get the QLD planning units from Marxan MaPP\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Calculate the resolution since Marxan MaPP for visulization purpose\nareas &lt;- st_area(QLD_Unit)\nareas_numeric &lt;- as.numeric(areas)\naverage_area &lt;- mean(areas_numeric)\n\n# Convert to numeric\naverage_area_km2 &lt;- average_area / 1e6\n\n# Get the number of rows\nn_rows &lt;- nrow(QLD_Unit)\n\n# Plot the shapefile with no fill color and number of rows in the title\nggplot(data = QLD_Unit) +\n  geom_sf(fill = NA, color = \"gray\") +\n  theme_minimal() +\n  ggtitle(paste(\"QLD Planning Units:\", n_rows, \"\\n\",\n                \"Resolution of planning in square kilometers:\", round(average_area_km2)))+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n2. I made a cost layer using the reciprocal of the distance to state-owned road as a surrogate of the cost.\nThe assumption is: the closer to the state owned road, the more expensive to purchase the unit.\n\nQLD_cost_road &lt;- st_read(\"qld_3species_Marxan/QLD_Cost/QLD_cost_road.shp\")\n\n# Plot the shapefile with continuous cost_road values\nggplot(QLD_cost_road) +\n  geom_sf(aes(fill = cost_road)) +\n  scale_fill_continuous(name = \"Cost\",\n                        low = \"lightblue\", high = \"red\",\n                        labels = c(\"0 (Low cost)\", \"1 (High cost)\"),\n                        breaks = c(0.01, 1)) +\n  theme_minimal() +\n  labs(title = \"Cost: using the distance to road of each Unit as a proxy\")+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n3. Biodiversity features. I used EcoCommons to produce three species’ SDM to start with.\n\nSpecies 1: koala\nSpecies 2: brush tailed rock-wallaby\nSpecies 3: beach stone curlew\n\n\n# Define the folder path where the rasters are stored\nfolder_path &lt;- \"qld_3species_Marxan/QLD_feature/\"\n\n# Get a list of all .tif files in the folder\nraster_files &lt;- list.files(path = folder_path, pattern = \"\\\\.tif$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Using QLD_Unit as the spatial vector for masking\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Function to convert rasters to data frames and combine them\nprepare_raster_data &lt;- function(raster_list, species_names) {\n\n  # Initialize an empty data frame\n  combined_df &lt;- data.frame()\n  # Loop through each raster and combine them into one data frame\n  for (i in seq_along(raster_list)) {\n    # Convert raster to a data frame\n    raster_df &lt;- as.data.frame(raster_list[[i]], xy = TRUE)\n    # Rename the third column to 'value' or any appropriate name for the raster values\n    names(raster_df)[3] &lt;- \"value\"\n    # Add a column to identify the species name\n    raster_df$species &lt;- species_names[i]\n    # Combine the raster data with the overall data frame\n    combined_df &lt;- bind_rows(combined_df, raster_df)\n}\n  return(combined_df)\n}\n\n# Prepare the combined data frame\ncombined_raster_df &lt;- prepare_raster_data(raster_list, species_names)\n\n# Create the ggplot with facet_wrap to display each raster in a separate facet\nggplot(combined_raster_df, aes(x = x, y = y, fill = value)) +  # Use the correct column name for fill\n  geom_raster()+\n  facet_wrap(~ species, ncol = 3) +  # Adjust ncol to control the number of columns\n  scale_fill_viridis_c() +  # You can adjust the color scale as needed\n  labs(title = \"Species SDM\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n4. We need to turn these SDMs to binary results (shapefies).\n\n# Define the folder paths where the rasters and CSV files are stored\nfolder_path_rasters &lt;- \"qld_3species_Marxan/QLD_feature/\"\nfolder_path_csvs &lt;- \"qld_3species_Marxan/model_evaluation/\"\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Get a list of all .tif files and CSV files in the folder\nraster_files &lt;- list.files(path = folder_path_rasters, pattern = \"\\\\.tif$\", full.names = TRUE)\ncsv_files &lt;- list.files(path = folder_path_csvs, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif/.csv extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Prepare a named list of rasters\nspecies_rasters &lt;- setNames(raster_list, species_names)\nspecies_csvs &lt;- setNames(csv_files, species_names)\n\n# Define UI for the application\nui &lt;- fluidPage(\n  titlePanel(\"Interactive TSS-based threshold for the probability of presence and absence of Species\"),\n  \n  # Use a loop to create a row for each species\n  lapply(species_names, function(species) {\n    fluidRow(\n      column(3, \n             h4(paste(\"Species:\", species)),\n             sliderInput(paste0(\"tss_value_\", species), \n                         \"Select TSS Value:\", \n                         min = 0, max = 1, value = 0.5, step = 0.01),\n             actionButton(paste0(\"run_analysis_\", species), \"Run Species Analysis\"),\n             br(),\n             textOutput(paste0(\"tpr_tnr_\", species))\n      ),\n      \n      column(4, \n             plotOutput(paste0(\"plot_\", species), width = \"400px\")\n      ),\n      \n      column(5, \n             plotOutput(paste0(\"species_plot_\", species))\n      )\n    )\n  })\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  \n  selected_raster &lt;- function(species) {\n    species_rasters[[species]]\n  }\n  \n  species_eval_data &lt;- function(species) {\n    csv_path &lt;- species_csvs[[species]]\n    \n    if (!file.exists(csv_path)) {\n      showNotification(paste(\"CSV file for\", species, \"not found!\"), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data &lt;- read.csv(csv_path)\n    \n    if (!all(c(\"tpr\", \"tnr\", \"tpv\") %in% names(eval_data))) {\n      showNotification(paste(\"Required columns missing in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    if (nrow(eval_data) == 0) {\n      showNotification(paste(\"No data found in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data$tss &lt;- round(eval_data$tpr + eval_data$tnr - 1, 3)\n    return(eval_data)\n  }\n  \n  lapply(species_names, function(species) {\n    eval_data &lt;- species_eval_data(species)\n    \n    if (!is.null(eval_data)) {\n      min_tss &lt;- min(eval_data$tss, na.rm = TRUE)\n      max_tss &lt;- max(eval_data$tss, na.rm = TRUE)\n      \n      updateSliderInput(session, paste0(\"tss_value_\", species), \n                        min = min_tss, \n                        max = max_tss, \n                        value = max_tss,\n                        step = 0.01)\n    }\n    \n    observeEvent(input[[paste0(\"tss_value_\", species)]], {\n      if (!is.null(eval_data)) {\n        row &lt;- which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))\n        \n        tpr &lt;- eval_data$tpr[row]\n        tnr &lt;- eval_data$tnr[row]\n        \n        output[[paste0(\"tpr_tnr_\", species)]] &lt;- renderText({\n          paste0(\"TPR (Sensitivity): \", round(tpr, 3), \n                 \", TNR (Specificity): \", round(tnr, 3))\n        })\n      }\n    })\n    \n    output[[paste0(\"plot_\", species)]] &lt;- renderPlot({\n      if (is.null(eval_data)) return(NULL)\n      \n      ggplot(eval_data, aes(x = tpv)) +\n        geom_line(aes(y = tpr, colour = \"TPR\"), linewidth = 1) +\n        geom_line(aes(y = tnr, colour = \"TNR\"), linewidth = 1) +\n        geom_line(aes(y = tss, colour = \"TSS\"), linewidth = 1) +\n        geom_vline(xintercept = eval_data$tpv[which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))],\n                   linetype = \"dotted\", color = \"red\", linewidth = 1) +\n        labs(title = paste(\"Sensitivity, Specificity, and TSS for\", species),\n             x = \"Threshold Probability Value\",\n             y = \"Value\") +\n        scale_colour_manual(values = c(\"TPR\" = \"blue\", \"TNR\" = \"green\", \"TSS\" = \"red\")) +\n        theme_minimal()\n    })\n    \n    observeEvent(input[[paste0(\"run_analysis_\", species)]], {\n      species_shp &lt;- process_species(selected_raster(species), QLD_Unit, species, output_dir, input[[paste0(\"tss_value_\", species)]])\n      \n      output[[paste0(\"species_plot_\", species)]] &lt;- renderPlot({\n        ggplot() +\n          geom_sf(data = QLD_Unit, fill = NA, color = \"grey\") +\n          geom_sf(data = species_shp, aes(fill = feature), color = NA) +\n          scale_fill_viridis_c(option = \"plasma\") +\n          labs(title = paste(\"Species Distribution for\", species),\n               x = \"Longitude\", y = \"Latitude\") +\n          theme_minimal()\n      })\n    })\n  })\n}\n\nprocess_species &lt;- function(raster_data, planning_unit, species_name, output_dir, tss_threshold) {\n  raster_data_transformed &lt;- project(raster_data, crs(vect(planning_unit)))\n  extracted_values &lt;- extract(raster_data_transformed, vect(planning_unit), fun = mean, na.rm = TRUE)\n  names(planning_unit)[names(planning_unit) == \"cost\"] &lt;- \"feature\"\n  planning_unit$feature &lt;- extracted_values[, 2]\n  \n  QLD_species &lt;- subset(planning_unit, feature &gt;= tss_threshold)\n  shapefile_base &lt;- file.path(output_dir, species_name)\n  st_write(QLD_species, paste0(shapefile_base, \".shp\"), delete_layer = TRUE)\n  \n  return(QLD_species)\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n5. Plot species SDM binary shapefile outputs for double check\n\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\n# List all the shapefiles in the directory (assuming each species has its own shapefile)\nspecies_files &lt;- list.files(output_dir, pattern = \"\\\\.shp$\", full.names = TRUE)\n\nspecies_files\n\n# Extract species names from the filenames (you can adjust this depending on your naming conventions)\nspecies_names &lt;- tools::file_path_sans_ext(basename(species_files))\n\n# Load all species shapefiles and add a species identifier\nspecies_sf_list &lt;- lapply(seq_along(species_files), function(i) {\n  sf &lt;- st_read(species_files[i])\n  sf$species &lt;- species_names[i]  # Add species name column\n  return(sf)\n})\n\n# Combine all species into one dataset\ncombined_species_sf &lt;- do.call(rbind, species_sf_list)\n\n# Plot the unit (base map) first and overlay the species habitats without borders\ncombined_plot_with_unit &lt;- ggplot() +\n  geom_sf(data = QLD_Unit, fill = NA, color = \"grey\", linewidth = 0.01) +  # Base map (QLD Unit)\n  geom_sf(data = combined_species_sf, aes(fill = species), color = NA) +  # No borders for species\n  scale_fill_manual(values = RColorBrewer::brewer.pal(n = length(species_names), name = \"Set1\")) +  # Automatically assign colors\n  theme_minimal() +\n  labs(title = \"Species Habitats within QLD Unit\",\n       subtitle = paste(species_names, collapse = \", \")) +  # List all species in subtitle\n  theme(legend.title = element_blank())\n\n# Display the plot\nprint(combined_plot_with_unit)\n\n\n\n\n\n\n\n\n6. We can also make a species presence and absence csv table.\n\n# Function to extract presence (1) and absence (0) from raster based on a threshold (e.g., 0.5)\n\nextract_presence_absence &lt;- function(raster_data, unit) {\n  extracted_values &lt;- extract(raster_data, vect(unit), fun = mean, na.rm = TRUE)\n  presence_absence &lt;- ifelse(extracted_values[, 2] &gt;= 0.5, 1, 0)\n  return(presence_absence)\n}\n\n# Create an empty presence-absence data frame\npresence_absence_df &lt;- data.frame(puid = QLD_Unit$puid)  # Assuming 'puid' is the unique identifier\n\n# Loop through each species raster in the raster list and extract presence-absence data\nfor (i in seq_along(raster_list)) {\n  # Generate a dynamic presence column name for the current species\n  presence_col_name &lt;- paste0(species_names[i], \"_presence\")\n  \n  # Extract presence/absence data and add it to the presence-absence dataframe\n  presence_absence_df[[species_names[i]]] &lt;- extract_presence_absence(raster_list[[i]], QLD_Unit)\n}\n\n# Write the final presence-absence data frame to a CSV file\noutput_csv &lt;- file.path(output_dir, \"presence_absence_species.csv\")\nwrite.csv(presence_absence_df, output_csv, row.names = FALSE)\n\n# Check the CSV output\nprint(head(presence_absence_df))\n\n  puid beach_stone_curlew_GLM brushtailed_rockwallaby_GLM Koala_GLM\n1    1                      0                           0         0\n2    2                      0                           0         0\n3    3                      0                           0         0\n4    4                      0                           0         0\n5    5                      0                           0         0\n6    6                      0                           0         0\n\n\n\n\n\n\n\n\n\n\nEcoCommons SDMs output of three species on Marxan MaPP\n\n\n\n\n\n\n\n\nNo Costs, neither SDMs\n\n\n\n\n\n\n\n\nSDMs only\n\n\n\n\n\n\n\n\nCosts only\n\n\n\n\n\n\n\n\nCosts and SDMs"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#introduction",
    "href": "sp/ecocommons-marxan-integration-poc.html#introduction",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Using the Species distribution modeling techniques provided by the EcoCommons Platform (www.ecocommons.org.au), we produced probability distribution maps for the three Queensland endangered species: koala, brush tailed rock-wallaby, and beach stone curlew.\nThen we adjusted the probability distribution maps of these three species with the planning units shapefile prepared by the Marxan MaPP, and ran four planning scenarios with a target of expanding the coverage of protected areas in QLD to 30%."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#ecocommons-outputs",
    "href": "sp/ecocommons-marxan-integration-poc.html#ecocommons-outputs",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Species records pulled from GBIF, ALA, EcoPlots, OBIS\nSpecies distribution modelling output: Species distribution Probability maps (This is the input tested in this project)."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#marxan-mapp-inputs",
    "href": "sp/ecocommons-marxan-integration-poc.html#marxan-mapp-inputs",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Shapefile of planning area and units.\nShapefile of cost.\nShapefile and csv of biodiversity features (Where EcoCommons can help!)."
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#ecocommons-connects-with-marxan-showcase",
    "href": "sp/ecocommons-marxan-integration-poc.html#ecocommons-connects-with-marxan-showcase",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "Make sure you are in the directory you want\n\ngetwd()\n\n[1] \"/Users/zhaoxiang/Documents/tmp/test/notebook-blog/sp\"\n\n# setwd(“/replace_this_with_your_actual_directory/ecocommons-marxan-integration-poc”)\n\nActivate the virtual environment “renv” to install and load all essential packages\n\n# install \"renv\" package if not been installed\nif (!requireNamespace(\"renv\", quietly = TRUE)) {\n  install.packages(\"renv\")\n}\n\nif (!file.exists(\"renv/activate.R\")) {\n   message(\"renv has not been initiated in this project. Initializing now...\")\n   renv::init()  # This initializes renv if it's not set up\n} else {\n   source(\"renv/activate.R\")  # This ensures the renv environment is activated\n   message(\"renv is activated.\")\n}\n\n# Ensure renv is installed and initialized\nif (file.exists(\"renv.lock\")) {\n  renv::restore()\n} else {\n  message(\"No renv.lock file found in the current directory.\")\n}\n\nInstall and load essential packages\n\n# Set CRAN mirror\noptions(repos = c(CRAN = \"https://cran.rstudio.com/\"))\n\n# First specify the packages of interest\npackages = c(\"shiny\", \"sf\", \"terra\", \"ggplot2\", \"ggspatial\", \"raster\", \"dplyr\", \"shiny\", \"httpuv\", \"rmarkdown\", \"knitr\", \"jsonlite\", \"reticulate\", \"htmltools\", \"pryr\")\n\n# Now load or install&load all. This process will take a long time since we are using a virtual environment and install a lot of packages.\npackage.check &lt;- lapply(\n  packages,\n  FUN = function(x) {\n    if (!require(x, character.only = TRUE)) {\n      install.packages(x, dependencies = TRUE)\n      library(x, character.only = TRUE)\n     }\n  }\n )\n\n\nSys.setenv(PROJ_LIB = \"/usr/local/Cellar/proj/9.5.0/share/proj\")\n\nrenv::snapshot()\n\n1. We get the QLD planning units from Marxan MaPP\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Calculate the resolution since Marxan MaPP for visulization purpose\nareas &lt;- st_area(QLD_Unit)\nareas_numeric &lt;- as.numeric(areas)\naverage_area &lt;- mean(areas_numeric)\n\n# Convert to numeric\naverage_area_km2 &lt;- average_area / 1e6\n\n# Get the number of rows\nn_rows &lt;- nrow(QLD_Unit)\n\n# Plot the shapefile with no fill color and number of rows in the title\nggplot(data = QLD_Unit) +\n  geom_sf(fill = NA, color = \"gray\") +\n  theme_minimal() +\n  ggtitle(paste(\"QLD Planning Units:\", n_rows, \"\\n\",\n                \"Resolution of planning in square kilometers:\", round(average_area_km2)))+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n2. I made a cost layer using the reciprocal of the distance to state-owned road as a surrogate of the cost.\nThe assumption is: the closer to the state owned road, the more expensive to purchase the unit.\n\nQLD_cost_road &lt;- st_read(\"qld_3species_Marxan/QLD_Cost/QLD_cost_road.shp\")\n\n# Plot the shapefile with continuous cost_road values\nggplot(QLD_cost_road) +\n  geom_sf(aes(fill = cost_road)) +\n  scale_fill_continuous(name = \"Cost\",\n                        low = \"lightblue\", high = \"red\",\n                        labels = c(\"0 (Low cost)\", \"1 (High cost)\"),\n                        breaks = c(0.01, 1)) +\n  theme_minimal() +\n  labs(title = \"Cost: using the distance to road of each Unit as a proxy\")+\n  theme(plot.title = element_text(hjust = 0.5))  # Center the title\n\n\n\n\n\n\n\n\n3. Biodiversity features. I used EcoCommons to produce three species’ SDM to start with.\n\nSpecies 1: koala\nSpecies 2: brush tailed rock-wallaby\nSpecies 3: beach stone curlew\n\n\n# Define the folder path where the rasters are stored\nfolder_path &lt;- \"qld_3species_Marxan/QLD_feature/\"\n\n# Get a list of all .tif files in the folder\nraster_files &lt;- list.files(path = folder_path, pattern = \"\\\\.tif$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Using QLD_Unit as the spatial vector for masking\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Function to convert rasters to data frames and combine them\nprepare_raster_data &lt;- function(raster_list, species_names) {\n\n  # Initialize an empty data frame\n  combined_df &lt;- data.frame()\n  # Loop through each raster and combine them into one data frame\n  for (i in seq_along(raster_list)) {\n    # Convert raster to a data frame\n    raster_df &lt;- as.data.frame(raster_list[[i]], xy = TRUE)\n    # Rename the third column to 'value' or any appropriate name for the raster values\n    names(raster_df)[3] &lt;- \"value\"\n    # Add a column to identify the species name\n    raster_df$species &lt;- species_names[i]\n    # Combine the raster data with the overall data frame\n    combined_df &lt;- bind_rows(combined_df, raster_df)\n}\n  return(combined_df)\n}\n\n# Prepare the combined data frame\ncombined_raster_df &lt;- prepare_raster_data(raster_list, species_names)\n\n# Create the ggplot with facet_wrap to display each raster in a separate facet\nggplot(combined_raster_df, aes(x = x, y = y, fill = value)) +  # Use the correct column name for fill\n  geom_raster()+\n  facet_wrap(~ species, ncol = 3) +  # Adjust ncol to control the number of columns\n  scale_fill_viridis_c() +  # You can adjust the color scale as needed\n  labs(title = \"Species SDM\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n4. We need to turn these SDMs to binary results (shapefies).\n\n# Define the folder paths where the rasters and CSV files are stored\nfolder_path_rasters &lt;- \"qld_3species_Marxan/QLD_feature/\"\nfolder_path_csvs &lt;- \"qld_3species_Marxan/model_evaluation/\"\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\nQLD_Unit &lt;- \"qld_3species_Marxan/QLD_plannningunits/cost-surface-template.shp\"  #This cost-surface-template was prepared by the Marxan Mapp with a resolution of 189 Km2, which is the highest resolution Marxan Mapp can give at this scale.\n\nQLD_Unit  &lt;- st_read(QLD_Unit)\nQLD_Unit  &lt;- st_simplify(QLD_Unit , dTolerance = 0.01) \n\n\n# Get a list of all .tif files and CSV files in the folder\nraster_files &lt;- list.files(path = folder_path_rasters, pattern = \"\\\\.tif$\", full.names = TRUE)\ncsv_files &lt;- list.files(path = folder_path_csvs, pattern = \"\\\\.csv$\", full.names = TRUE)\n\n# Extract the species names from the file names (removing the folder path and .tif/.csv extension)\nspecies_names &lt;- tools::file_path_sans_ext(basename(raster_files))\n\n# Read all raster files in one go using lapply\nraster_list &lt;- lapply(raster_files, rast)  # Use rast() from terra for reading rasters\n\n# Transform the raster CRS to match the vector CRS and apply masking in one step\nraster_list &lt;- lapply(raster_list, function(r) {\n  r_transformed &lt;- project(r, crs(vect(QLD_Unit)))\n  mask(r_transformed, vect(QLD_Unit))\n})\n\n# Prepare a named list of rasters\nspecies_rasters &lt;- setNames(raster_list, species_names)\nspecies_csvs &lt;- setNames(csv_files, species_names)\n\n# Define UI for the application\nui &lt;- fluidPage(\n  titlePanel(\"Interactive TSS-based threshold for the probability of presence and absence of Species\"),\n  \n  # Use a loop to create a row for each species\n  lapply(species_names, function(species) {\n    fluidRow(\n      column(3, \n             h4(paste(\"Species:\", species)),\n             sliderInput(paste0(\"tss_value_\", species), \n                         \"Select TSS Value:\", \n                         min = 0, max = 1, value = 0.5, step = 0.01),\n             actionButton(paste0(\"run_analysis_\", species), \"Run Species Analysis\"),\n             br(),\n             textOutput(paste0(\"tpr_tnr_\", species))\n      ),\n      \n      column(4, \n             plotOutput(paste0(\"plot_\", species), width = \"400px\")\n      ),\n      \n      column(5, \n             plotOutput(paste0(\"species_plot_\", species))\n      )\n    )\n  })\n)\n\n# Define server logic\nserver &lt;- function(input, output, session) {\n  \n  selected_raster &lt;- function(species) {\n    species_rasters[[species]]\n  }\n  \n  species_eval_data &lt;- function(species) {\n    csv_path &lt;- species_csvs[[species]]\n    \n    if (!file.exists(csv_path)) {\n      showNotification(paste(\"CSV file for\", species, \"not found!\"), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data &lt;- read.csv(csv_path)\n    \n    if (!all(c(\"tpr\", \"tnr\", \"tpv\") %in% names(eval_data))) {\n      showNotification(paste(\"Required columns missing in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    if (nrow(eval_data) == 0) {\n      showNotification(paste(\"No data found in CSV for\", species), type = \"error\")\n      return(NULL)\n    }\n    \n    eval_data$tss &lt;- round(eval_data$tpr + eval_data$tnr - 1, 3)\n    return(eval_data)\n  }\n  \n  lapply(species_names, function(species) {\n    eval_data &lt;- species_eval_data(species)\n    \n    if (!is.null(eval_data)) {\n      min_tss &lt;- min(eval_data$tss, na.rm = TRUE)\n      max_tss &lt;- max(eval_data$tss, na.rm = TRUE)\n      \n      updateSliderInput(session, paste0(\"tss_value_\", species), \n                        min = min_tss, \n                        max = max_tss, \n                        value = max_tss,\n                        step = 0.01)\n    }\n    \n    observeEvent(input[[paste0(\"tss_value_\", species)]], {\n      if (!is.null(eval_data)) {\n        row &lt;- which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))\n        \n        tpr &lt;- eval_data$tpr[row]\n        tnr &lt;- eval_data$tnr[row]\n        \n        output[[paste0(\"tpr_tnr_\", species)]] &lt;- renderText({\n          paste0(\"TPR (Sensitivity): \", round(tpr, 3), \n                 \", TNR (Specificity): \", round(tnr, 3))\n        })\n      }\n    })\n    \n    output[[paste0(\"plot_\", species)]] &lt;- renderPlot({\n      if (is.null(eval_data)) return(NULL)\n      \n      ggplot(eval_data, aes(x = tpv)) +\n        geom_line(aes(y = tpr, colour = \"TPR\"), linewidth = 1) +\n        geom_line(aes(y = tnr, colour = \"TNR\"), linewidth = 1) +\n        geom_line(aes(y = tss, colour = \"TSS\"), linewidth = 1) +\n        geom_vline(xintercept = eval_data$tpv[which.min(abs(eval_data$tss - input[[paste0(\"tss_value_\", species)]]))],\n                   linetype = \"dotted\", color = \"red\", linewidth = 1) +\n        labs(title = paste(\"Sensitivity, Specificity, and TSS for\", species),\n             x = \"Threshold Probability Value\",\n             y = \"Value\") +\n        scale_colour_manual(values = c(\"TPR\" = \"blue\", \"TNR\" = \"green\", \"TSS\" = \"red\")) +\n        theme_minimal()\n    })\n    \n    observeEvent(input[[paste0(\"run_analysis_\", species)]], {\n      species_shp &lt;- process_species(selected_raster(species), QLD_Unit, species, output_dir, input[[paste0(\"tss_value_\", species)]])\n      \n      output[[paste0(\"species_plot_\", species)]] &lt;- renderPlot({\n        ggplot() +\n          geom_sf(data = QLD_Unit, fill = NA, color = \"grey\") +\n          geom_sf(data = species_shp, aes(fill = feature), color = NA) +\n          scale_fill_viridis_c(option = \"plasma\") +\n          labs(title = paste(\"Species Distribution for\", species),\n               x = \"Longitude\", y = \"Latitude\") +\n          theme_minimal()\n      })\n    })\n  })\n}\n\nprocess_species &lt;- function(raster_data, planning_unit, species_name, output_dir, tss_threshold) {\n  raster_data_transformed &lt;- project(raster_data, crs(vect(planning_unit)))\n  extracted_values &lt;- extract(raster_data_transformed, vect(planning_unit), fun = mean, na.rm = TRUE)\n  names(planning_unit)[names(planning_unit) == \"cost\"] &lt;- \"feature\"\n  planning_unit$feature &lt;- extracted_values[, 2]\n  \n  QLD_species &lt;- subset(planning_unit, feature &gt;= tss_threshold)\n  shapefile_base &lt;- file.path(output_dir, species_name)\n  st_write(QLD_species, paste0(shapefile_base, \".shp\"), delete_layer = TRUE)\n  \n  return(QLD_species)\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n5. Plot species SDM binary shapefile outputs for double check\n\noutput_dir &lt;- \"qld_3species_Marxan/QLD_feature/Marxan_feature_input/\"\n\n# List all the shapefiles in the directory (assuming each species has its own shapefile)\nspecies_files &lt;- list.files(output_dir, pattern = \"\\\\.shp$\", full.names = TRUE)\n\nspecies_files\n\n# Extract species names from the filenames (you can adjust this depending on your naming conventions)\nspecies_names &lt;- tools::file_path_sans_ext(basename(species_files))\n\n# Load all species shapefiles and add a species identifier\nspecies_sf_list &lt;- lapply(seq_along(species_files), function(i) {\n  sf &lt;- st_read(species_files[i])\n  sf$species &lt;- species_names[i]  # Add species name column\n  return(sf)\n})\n\n# Combine all species into one dataset\ncombined_species_sf &lt;- do.call(rbind, species_sf_list)\n\n# Plot the unit (base map) first and overlay the species habitats without borders\ncombined_plot_with_unit &lt;- ggplot() +\n  geom_sf(data = QLD_Unit, fill = NA, color = \"grey\", linewidth = 0.01) +  # Base map (QLD Unit)\n  geom_sf(data = combined_species_sf, aes(fill = species), color = NA) +  # No borders for species\n  scale_fill_manual(values = RColorBrewer::brewer.pal(n = length(species_names), name = \"Set1\")) +  # Automatically assign colors\n  theme_minimal() +\n  labs(title = \"Species Habitats within QLD Unit\",\n       subtitle = paste(species_names, collapse = \", \")) +  # List all species in subtitle\n  theme(legend.title = element_blank())\n\n# Display the plot\nprint(combined_plot_with_unit)\n\n\n\n\n\n\n\n\n6. We can also make a species presence and absence csv table.\n\n# Function to extract presence (1) and absence (0) from raster based on a threshold (e.g., 0.5)\n\nextract_presence_absence &lt;- function(raster_data, unit) {\n  extracted_values &lt;- extract(raster_data, vect(unit), fun = mean, na.rm = TRUE)\n  presence_absence &lt;- ifelse(extracted_values[, 2] &gt;= 0.5, 1, 0)\n  return(presence_absence)\n}\n\n# Create an empty presence-absence data frame\npresence_absence_df &lt;- data.frame(puid = QLD_Unit$puid)  # Assuming 'puid' is the unique identifier\n\n# Loop through each species raster in the raster list and extract presence-absence data\nfor (i in seq_along(raster_list)) {\n  # Generate a dynamic presence column name for the current species\n  presence_col_name &lt;- paste0(species_names[i], \"_presence\")\n  \n  # Extract presence/absence data and add it to the presence-absence dataframe\n  presence_absence_df[[species_names[i]]] &lt;- extract_presence_absence(raster_list[[i]], QLD_Unit)\n}\n\n# Write the final presence-absence data frame to a CSV file\noutput_csv &lt;- file.path(output_dir, \"presence_absence_species.csv\")\nwrite.csv(presence_absence_df, output_csv, row.names = FALSE)\n\n# Check the CSV output\nprint(head(presence_absence_df))\n\n  puid beach_stone_curlew_GLM brushtailed_rockwallaby_GLM Koala_GLM\n1    1                      0                           0         0\n2    2                      0                           0         0\n3    3                      0                           0         0\n4    4                      0                           0         0\n5    5                      0                           0         0\n6    6                      0                           0         0"
  },
  {
    "objectID": "sp/ecocommons-marxan-integration-poc.html#marxan-four-scenarios-solutions",
    "href": "sp/ecocommons-marxan-integration-poc.html#marxan-four-scenarios-solutions",
    "title": "EcoCommons Marxan MaPP connection",
    "section": "",
    "text": "EcoCommons SDMs output of three species on Marxan MaPP\n\n\n\n\n\n\n\n\nNo Costs, neither SDMs\n\n\n\n\n\n\n\n\nSDMs only\n\n\n\n\n\n\n\n\nCosts only\n\n\n\n\n\n\n\n\nCosts and SDMs"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EcoCommons Notebooks",
    "section": "",
    "text": "EcoCommons Notebooks\nEcoCommons Notebooks represent an exciting expansion of the platform’s capabilities, offering a new layer of flexibility for advanced users. By incorporating notebooks, EcoCommons enhances its ability to serve the environmental data science community, enabling users to engage with cutting-edge methods, customize workflows, and increase reproducibility in their research. These notebooks, hosted on trusted cloud providers, provide a transparent, open-access approach to environmental data analysis while adhering to the FAIR principles. With planned monthly releases, EcoCommons Notebooks will empower users to explore complex topics such as species migration, community modeling, and data cleaning for biodiversity research."
  },
  {
    "objectID": "sdms/dataprep.html",
    "href": "sdms/dataprep.html",
    "title": "Data Preparation Overview",
    "section": "",
    "text": "Welcome to the Data Preparation section! Here, you can find various guides and resources to help you with the preparation of data for Species Distribution Models (SDM).\n\n\nBelow is a list of specific topics related to data preparation. Click on each link to access more detailed guides.\n\n\nEnvironmental Data Preparation\nStep-by-step instructions on how to handle raster data, including reprojecting, cropping, and masking.\n\n\n\nOccurrence Data Preparation\nLearn how to download, clean, and format occurrence data for your species of interest.\n\nIf you have questions or suggestions, please contact the EcoCommons team."
  },
  {
    "objectID": "sdms/dataprep.html#available-guides",
    "href": "sdms/dataprep.html#available-guides",
    "title": "Data Preparation Overview",
    "section": "",
    "text": "Below is a list of specific topics related to data preparation. Click on each link to access more detailed guides.\n\n\nEnvironmental Data Preparation\nStep-by-step instructions on how to handle raster data, including reprojecting, cropping, and masking.\n\n\n\nOccurrence Data Preparation\nLearn how to download, clean, and format occurrence data for your species of interest.\n\nIf you have questions or suggestions, please contact the EcoCommons team."
  }
]